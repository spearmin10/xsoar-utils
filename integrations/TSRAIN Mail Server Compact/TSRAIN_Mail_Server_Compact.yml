commonfields:
  id: TSRAIN Mail Server Compact
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: TSRAIN Mail Server Compact
display: TSRAIN Mail Server Compact
category: Utilities
image: data:image/png;base64,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
description: Air-gapped email server working on an integration instance.
detaileddescription: |-
  ### How to configure an instance.

  #### 0.  Go to ABOUT > Troubleshooting > Server Configuration
    Set  instance.execute.external = true

  #### 1. Create an instance
  Add instance with the parameters below:
    - Instance Name: tsrain
    - Listen Port: 8118

  You can access the webmail UI at
    - https://xsoar-server/instance/execute/tsrain/
    - http://xsoar-server:8118/
      ```
        username: any email address (e.g. test@test.lan)
        password: Password123$
      ```

  Admin UI
    - https://xsoar-server/instance/execute/tsrain/?admin
    - http://xsoar-server:8118/?admin
      ```
         username: admin
         password: <Run !tsrc-get-default-admin-password>
      ```

  #### 2. Get the gateway address of the docker bridge network
  Run !tsrc-get-gateways in CLI, and memorize the gateway IP for 3 and 4

  #### 3. (Optional) Configure 'Mail Sender (New)' to connect to the server.
  Add an instance with the parameters below:
    - Mail server hostname or IP address: <gateway IP>
    - SMTP Port: 8118
    - Sender address: any email address

  #### 4. (Optional) Configure 'Mail Listener v2' to connect to the server.
  Add an instance with the parameters below:
    - Mail server hostname or IP address: <gateway IP>
     - IMAP Port: 8118
     - Username: your email address
     - Password: Password123$
     - Incoming mail folder: INBOX
     - Use TLS for connection: Yes
     - Trust any certificate (not secure): Yes

  ### NOTE:
   - Emails are stored in memory. All the emails are gone whenever restarting the docker container.
configuration:
- advanced: true
  display: Long Running Instance
  name: longRunning
  defaultvalue: "true"
  type: 8
  required: false
- display: Listen Port
  name: longRunningPort
  defaultvalue: "8118"
  type: 0
  required: true
  additionalinfo: The port which is shared with Rainloop Web UI, SMTP and IMAP4
- display: Incident type
  name: incidentType
  type: 13
  required: false
- advanced: true
  display: User's mailbox password in the local TSRAIN
  name: localMailboxPassword
  defaultvalue: Password123$
  type: 4
  required: false
  additionalinfo: The password is applied for all the users, default password is 'Password123$'
- advanced: true
  display: Default 'admin' password in the local TSRAIN
  name: localDefaultAdminPassword
  type: 4
  required: false
  additionalinfo: The password is randomly generated by default
- advanced: true
  display: TSRAIN Remote Address
  name: remoteTsrainAddress
  type: 0
  required: false
  additionalinfo: Hostname and port number of the remote server. (e.g. tsrain.cortex-sv.net:444)
- advanced: true
  display: Client Credential Type
  name: clientCredentialType
  type: 15
  required: false
  options:
  - PKCS#12 PEM
  - Cert + Private Key PEM
- advanced: true
  display: Protected or public client credential
  displaypassword: Unprotected client credential or Key/Password to decrypt credential
  name: clientCredential
  type: 9
  required: false
  additionalinfo: PKCS#12 in base64 used for client authentication
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- advanced: true
  display: Active Shared Commands
  name: activeSharedCommands
  type: 16
  required: false
  options:
  - send-mail
  - reply-mail
- advanced: true
  display: Default sender address
  name: senderAddress
  defaultvalue: Cortex XSOAR <noreply@demisto.com>
  type: 0
  required: false
script:
  script: |
    import os
    import time
    import socket
    import select
    import string
    import random
    import base64
    import re
    import ssl
    import subprocess
    import traceback
    import ipaddress
    import netifaces
    import smtplib
    import mimetypes
    import threading
    import email.message
    import email.encoders
    import email.utils
    import email.parser
    from enum import Enum
    from tempfile import NamedTemporaryFile
    from email.mime.text import MIMEText
    from email.mime.audio import MIMEAudio
    from email.mime.base import MIMEBase
    from email.mime.image import MIMEImage
    from email.mime.multipart import MIMEMultipart
    from socketserver import BaseServer, BaseRequestHandler, ThreadingTCPServer
    from multiprocessing import Process
    from itertools import zip_longest
    from cryptography import x509
    from cryptography.x509.oid import NameOID
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.primitives.serialization import pkcs12
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.asymmetric import rsa
    from typing import Tuple, List, Dict, Any, Iterator


    #LOCAL_SMTP_PORT_DEFAULT = 25
    LOCAL_SMTP_PORT = 10025
    LOCAL_POP3_PORT = 10110
    LOCAL_IMAP4_PORT = 10143
    LOCAL_RAINLOOP_PORT = 10080

    DEFAULT_SOCKET_TIMEOUT = 30
    DEFAULT_PUBLIC_KEY_SIZE = 2048
    LOCAL_DEFAULT_MAILBOX_PASSWORD = 'Password123$'
    INTEGRATION_NAME = 'XSOAR TSRAIN Mail Server Compact'


    class ClientCredentialType(Enum):
        PKCS12_PEM = 'PKCS#12 PEM'
        CERT_PRIVATE_KEY_PEM = 'Cert + Private Key PEM'


    class PrivateCredential:
        """ This class stores a private credential that is sensitive or should be protected such as password or private key.
        """
        def __init__(
            self,
            private_credential: str,
            decryption_password: str | None = None
        ) -> None:
            """
            :param private_credential: The private credential
            :param decryption_password: The password to decrypt the private credential if it is encrypted
            """
            self.__private_credential = private_credential
            self.__decryption_password = decryption_password

        @property
        def private_credential(
            self
        ) -> str:
            return self.__private_credential

        @property
        def decryption_password(
            self
        ) -> str | None:
            return self.__decryption_password


    class Credential:
        def __init__(
            self,
            private_credential: PrivateCredential,
            public_credential: str | None = None
        ) -> None:
            """
            :param private_credential: The private credential
            :param public_credential: The public credential
            """
            self.__private_credential = private_credential
            self.__public_credential = public_credential

        @property
        def private_credential(
            self
        ) -> PrivateCredential:
            return self.__private_credential

        @property
        def public_credential(
            self
        ) -> str | None:
            return self.__public_credential

        def get_private_credential(
            self,
            pem_format: bool = False
        ) -> PrivateCredential:
            if pem_format:
                pem = Credential.replace_spaces_in_credentials(self.__private_credential.private_credential)
                if not pem.endswith('\n'):
                    pem += '\n'

                return PrivateCredential(
                    private_credential=pem,
                    decryption_password=self.__private_credential.decryption_password)
            else:
                return self.__private_credential

        def get_public_credential(
            self,
            pem_format: bool = False
        ) -> str | None:
            if self.__public_credential and pem_format:
                pem = Credential.replace_spaces_in_credentials(self.__public_credential)
                return pem if pem.endswith('\n') else pem + '\n'
            else:
                return self.__public_credential

        @staticmethod
        def replace_spaces_in_credentials(
            credentials: str | None
        ) -> str | None:
            """
            This function is used in case of credential from type: 9 is in the wrong format
            of one line with spaces instead of multiple lines.

            :param credentials: the credentials to replace spaces in.
            :return: the credential with spaces replaced with new lines if the credential is in the correct format,
                     otherwise the credential will be returned as is.
            """
            if not credentials:
                return credentials

            def __pairwise(iterable):
                x = iter(iterable)
                return zip(x, x)

            return re.sub(
                r'(?P<lseps>\s*)(?P<begin>-----BEGIN(.*?)-----)(?P<begin_sep>\s)(?P<header>([^:]+:\s\S+\s?)*)(?P<body>.*?)(?P<end_sep>\s)(?P<end>-----END(.*?)-----)(?P<tseps>\s*)',
                lambda m: m.group('lseps').replace(' ', '\n')
                + m.group('begin')
                + m.group('begin_sep').replace(' ', '\n')
                + '\n'.join([' '.join(x) for x in __pairwise(m.group('header').split(' '))])
                + ('\n' if m.group('header') else '')
                + m.group('body').replace(' ', '\n')
                + m.group('end_sep').replace(' ', '\n')
                + m.group('end')
                + m.group('tseps').replace(' ', '\n'),
                credentials,
                flags=re.DOTALL)

        @staticmethod
        def get_body_from_pem(
            pem: str,
            label: str
        ) -> str | None:
            label = re.escape(label)
            pattern = f'^-----BEGIN {label}-----$(.*?)^-----END {label}-----$'
            if m := re.search(pattern, pem, re.DOTALL | re.MULTILINE):
                return m[1]
            return None

        @staticmethod
        def enum_pem(
            text: str
        ) -> Iterator[Tuple[str, str]]:
            """ Enumerate each PEM text containing in the text given

            :param text: The text
            :return: An iterator to enumerate label and pem text.
            """
            for m in re.finditer(
                r'^-----BEGIN ([^-]+)-----$.*?^-----END ([^-]+)-----$\n',
                text,
                flags=re.DOTALL | re.MULTILINE):
                if m[1] == m[2]:
                    yield m[1], m[0]


    class Settings:
        def __init__(
            self,
            params: Dict[str, Any]
        ) -> None:
            params = assign_params(**params)
            self.__params = params

            host_port, _, docker_port = (params.get('longRunningPort') or '').partition(':')
            self.__host_port = int(host_port or docker_port or 0)
            self.__docker_port = int(docker_port or host_port or 0)
            self.__local_mailbox_password = params.get('localMailboxPassword') or LOCAL_DEFAULT_MAILBOX_PASSWORD
            self.__local_default_admin_password = params.get('localDeafultAdminPassword')
            self.__insecure = argToBoolean(params.get('insecure', 'false'))
            self.__active_shared_commands = argToList(params.get('activeSharedCommands'))
            self.__sender_email_address = params.get('senderAddress') or ''
            self.__client_credential_type = params.get('clientCredentialType')
            if self.__client_credential_type:
                self.__client_credential = self.__get_credential(
                    credentials=params.get('clientCredential') or {},
                    private_credential_only=True
                )
            else:
                self.__client_credential = None

        def __get_credential(
            self,
            credentials: Dict[str, Any],
            private_credential_only: bool = False
        ) -> Credential | None:
            """ Get public and private credential from the credentials

            :param credentials: The credentials
            :param private_credential_only: Set to True if the credentials only have private credentials, otherwise False.
            :return The public and private credential.
            """
            if credentials.get('credential'):
                if ssh_key := demisto.get(credentials, 'credentials.sshkey'):
                    ssh_key_pass = demisto.get(credentials, 'credentials.sshkeyPass') or \
                                   demisto.get(credentials, 'credentials.password') or None

                    public_credential = credentials.get('credentials.user') or None
                    private_credential = PrivateCredential(
                        private_credential=ssh_key,
                        decryption_password=ssh_key_pass
                    )
                elif password := demisto.get(credentials, 'credentials.password'):
                    public_credential = credentials.get('credentials.user') or None
                    private_credential = PrivateCredential(private_credential=password)
                else:
                    return None
            elif password := demisto.get(credentials, 'password'):
                public_credential = credentials.get('identifier') or None
                if private_credential_only and\
                    public_credential and\
                    not re.search(r'-----BEGIN ([^-]+)-----.*?-----END ([^-]+)-----', password, flags=re.DOTALL):
                    private_credential = PrivateCredential(
                        private_credential=public_credential,
                        decryption_password=password
                    )
                    public_credential = None
                else:
                    private_credential = PrivateCredential(private_credential=password)
            else:
                # No credentials or only identifier is provided
                return None
            return Credential(private_credential=private_credential, public_credential=public_credential)

        @property
        def host_port(
            self
        ) -> int:
            return self.__host_port

        @property
        def docker_port(
            self
        ) -> int:
            return self.__docker_port

        @property
        def is_remote_mode(
            self
        ) -> bool:
            return True if self.__params.get('remoteTsrainAddress') else False

        @property
        def remote_address(
            self
        ) -> Tuple[str, int]:
            if not (remote_addr := self.__params.get('remoteTsrainAddress')):
                raise DemistoException("It's working in the local tsrain mode.")

            remote_host, sep, remote_port = remote_addr.partition(':')
            if not remote_host or sep != ':':
                raise DemistoException(f'Invalid remote host - {remote_addr}')
            return remote_host, int(remote_port)

        @property
        def local_mailbox_password(
            self
        ) -> str:
            return self.__local_mailbox_password

        @property
        def local_default_admin_password(
            self
        ) -> str | None:
            return self.__local_default_admin_password

        @property
        def insecure(
            self
        ) -> bool:
            return self.__insecure

        @property
        def active_shared_commands(
            self
        ) -> List[str]:
            return self.__active_shared_commands

        @property
        def sender_email_address(
            self
        ) -> str:
            return self.__sender_email_address

        @property
        def get_params(
            self
        ) -> Dict[str, Any]:
            return self.__params

        def get_client_credentials_pem(
            self
        ) -> Tuple[str, str, Optional[str]] | None:
            """ Get certificates and private key PEM for client authentication with the password to decrypt it

            :return The certificates PEMs, private key PEMs, and the password to decrypt the private keys (Optional).
            """
            if self.__client_credential_type == ClientCredentialType.PKCS12_PEM.value:
                if not self.__client_credential:
                    raise DemistoException('Client PKCS#12 is required')

                p12_cred = self.__client_credential.get_private_credential(pem_format=True)
                p12_base64 = Credential.get_body_from_pem(p12_cred.private_credential, 'PKCS12') or p12_cred.private_credential
                if not p12_base64:
                    raise DemistoException('Invalid Client PKCS#12 PEM')
                p12_passwd = p12_cred.decryption_password or ''

                pkey, cert, _ = pkcs12.load_key_and_certificates(
                    base64.b64decode(p12_base64.encode('utf-8')),
                    p12_passwd.encode('utf-8'),
                    backend=default_backend()
                )
                if not pkey:
                    raise DemistoException('No private keys in Client PKCS#12')
                if not cert:
                    raise DemistoException('No certificates in Client PKCS#12')

                pkey_pem = pkey.private_bytes(
                    encoding=serialization.Encoding.PEM,
                    format=serialization.PrivateFormat.TraditionalOpenSSL,
                    encryption_algorithm=serialization.NoEncryption()
                )
                cert_pem = cert.public_bytes(encoding=serialization.Encoding.PEM)
                return cert_pem.decode(), pkey_pem.decode(), None

            elif self.__client_credential_type == ClientCredentialType.CERT_PRIVATE_KEY_PEM.value:
                if not self.__client_credential:
                    raise DemistoException('Certificates and Private key are required')

                pkey_cred = self.__client_credential.get_private_credential(pem_format=True)
                pem_text = pkey_cred.private_credential
                pem_text += '\n'
                pem_text += self.__client_credential.get_public_credential(pem_format=True) or ''

                certs_pem = []
                pkeys_pem = []
                for label, pem in Credential.enum_pem(pem_text):
                    if label == 'CERTIFICATE':
                        certs_pem.append(pem)
                    elif 'PRIVATE KEY' in label:
                        pkeys_pem.append(pem)
                if not certs_pem or not pkeys_pem:
                    raise DemistoException('Certificates and Private key are required')
                else:
                    return '\n'.join(certs_pem), '\n'.join(pkeys_pem), pkey_cred.decryption_password
            else:
                return None


    SETTINGS = Settings(demisto.params())


    def get_gateway_interfaces(
    ) -> List[Dict[str, str]]:
        """ Get the gateway interfaces

        :return: List of interfaces (keys: 'IP', 'Interface', 'Default')
        """
        return [{
            'IP': a[0] if len(a) > 0 else None,
            'Interface': a[1] if len(a) > 1 else None,
            'Default': a[2] if len(a) > 2 else None
        } for k, v in netifaces.gateways().items() if k != 'default' for a in v]


    def get_local_addresses(
    ) -> List[dict]:
        """ Get local addresses

        :return: List of local address object {'addr', 'netmask', 'broadcast'}
        """
        alist = []
        for ifname in netifaces.interfaces():
            ifinfo = netifaces.ifaddresses(ifname)
            for ininfo in ifinfo.values():
                for ainfo in ininfo:
                    if ainfo.get('addr') and ainfo.get('netmask'):
                        try:
                            addr = ipaddress.ip_address(ainfo['addr'])
                            mask = ipaddress.ip_network(ainfo['netmask'], strict=False)
                            exploded = mask.broadcast_address.exploded
                            if addr.version == 4:
                                bcast = ipaddress.IPv4Address(int(addr) | (0xffffffff ^ int(ipaddress.IPv4Address(exploded))))
                                alist.append({
                                    'addr': addr,
                                    'netmask': mask,
                                    'broadcast': bcast
                                })
                        except ValueError:
                            pass
        return alist


    def save_port_fowarder_address(
        ips: List[str] | None,
        port: int | None
    ) -> None:
        """ Save the port forwarder addresses to the integration context

        :param ips: The list of IP addresses of the port forwarder
        :param port: The port number
        """
        if port is None:
            ips = None
        elif not ips:
            ips = [a['addr'].exploded for a in get_local_addresses() if not a['addr'].is_loopback]

        x = demisto.getIntegrationContext() or {}
        if ips is None:
            x.pop('PortForwarderAddresses', None)
        else:
            x['PortForwarderAddresses'] = json.dumps([{
                'Host': ip,
                'Port': port
            } for ip in ips])
        demisto.setIntegrationContext(x)


    def get_port_fowarder_addresses(
    ) -> List[Tuple[str, int]]:
        """ Get port forwarder addresses to connect from the internal mail client

        :return: The list of host names and ports
        """
        addrs = []
        if ents := (demisto.getIntegrationContext() or {}).get('PortForwarderAddresses'):
            for ent in json.loads(ents):
                if 'Host' in ent and 'Port' in ent:
                    addrs.append((ent['Host'], ent['Port']))

        gw_ips = [gw['IP'] for gw in get_gateway_interfaces() if 'IP' in gw]
        for host, port in list(addrs):
            addrs.extend([(gw, port) for gw in gw_ips])
            addrs.append(('127.0.0.1', port))

        return list(set(addrs))


    def serve_forever(
        server: BaseServer
    ) -> None:
        """ Run server.serve_forever()

        :param server: The server
        """
        server.serve_forever()


    def extract_email_addresses(
        fields: List[str]
    ) -> List[str]:
        """ Extract email addresses from email fields

        :param names: A list of email header fields
        :return: A list of email address.
        """
        addrs = []
        for a in email.utils.getaddresses(fields):
            if len(a) >= 1 and a[1]:
                addrs.append(a[1])
        return addrs


    class PortForwardingSettings:
        def __init__(
            self,
            remote_addr: Tuple[str, int] | None = None,
            ssl_server_context: ssl.SSLContext | None = None,
            ssl_client_context: ssl.SSLContext | None = None,
            local_smtp_port: int = LOCAL_SMTP_PORT,
            local_pop3_port: int = LOCAL_POP3_PORT,
            local_imap4_port: int = LOCAL_IMAP4_PORT,
            local_rainloop_port: int = LOCAL_RAINLOOP_PORT,
        ) -> None:
            if remote_addr is None:
                self.__remote_host = None
                self.__remote_port = None
            else:
                self.__remote_host, self.__remote_port = remote_addr

            self.__ssl_server_context = ssl_server_context
            self.__ssl_client_context = ssl_client_context
            self.__local_smtp_port = local_smtp_port
            self.__local_pop3_port = local_pop3_port
            self.__local_imap4_port = local_imap4_port
            self.__local_rainloop_port = local_rainloop_port

        @property
        def remote_host(
            self
        ) -> str | None:
            return self.__remote_host

        @property
        def remote_port(
            self
        ) -> int | None:
            return self.__remote_port

        @property
        def ssl_server_context(
            self
        ) -> ssl.SSLContext | None:
            return self.__ssl_server_context

        @property
        def ssl_client_context(
            self
        ) -> ssl.SSLContext | None:
            return self.__ssl_client_context

        @property
        def local_smtp_port(
            self
        ) -> int | None:
            return self.__local_smtp_port

        @property
        def local_pop3_port(
            self
        ) -> int | None:
            return self.__local_pop3_port

        @property
        def local_imap4_port(
            self
        ) -> int | None:
            return self.__local_imap4_port

        @property
        def local_rainloop_port(
            self
        ) -> int | None:
            return self.__local_rainloop_port


    class ProxyUtils:
        """
        Proxy Utilities
        """
        @staticmethod
        def communicate_tcp_tcp(
            s1: socket.socket,
            s2: socket.socket
        ) -> None:
            """ Port Forwarding: TCP <-> TCP

            :param s1: A TCP session 1
            :param s2: A TCP session 2
            """
            buf1 = None
            buf2 = None

            s1.setblocking(True)
            s2.setblocking(True)

            while True:
                rset = []
                wset = []
                if s2 is not None:
                    if buf2:
                        wset.append(s2)
                    if s1 is not None and not buf1:
                        rset.append(s2)

                if s1 is not None:
                    if buf1:
                        wset.append(s1)
                    if s2 is not None and not buf2:
                        rset.append(s1)

                if not rset and not wset:
                    break

                r, w, x = select.select(rset, wset, [])
                if s1 in r:
                    buf2 = s1.recv(1024)
                    if not buf2:
                        s1 = None

                if s1 in w:
                    n = s1.send(buf1)
                    if n > 0:
                        buf1 = buf1[n:]

                if s2 in r:
                    buf1 = s2.recv(1024)
                    if not buf1:
                        s2 = None

                if s2 in w:
                    n = s2.send(buf2)
                    if n > 0:
                        buf2 = buf2[n:]

        @staticmethod
        def communicate_tcp_ssl(
            s1: socket.socket,
            s2: ssl.SSLSocket
        ) -> None:
            """ Port Forwarding: TCP <-> SSL

            :param s1: A TCP session
            :param s2: A SSL session
            """
            buf1 = None
            buf2 = None

            s1.setblocking(True)
            s2.setblocking(False)
            s2_r = ssl.SSL_ERROR_ZERO_RETURN
            s2_w = ssl.SSL_ERROR_ZERO_RETURN

            while True:
                rset = []
                wset = []
                if s2 is not None:
                    if buf2:
                        if s2_w in (ssl.SSL_ERROR_WANT_WRITE, ssl.SSL_ERROR_ZERO_RETURN):
                            wset.append(s2)
                        elif s2_w == ssl.SSL_ERROR_WANT_READ:
                            rset.append(s2)
                    if s1 is not None and not buf1:
                        if s2_r in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_ZERO_RETURN):
                            rset.append(s2)
                        elif s2_r == ssl.SSL_ERROR_WANT_WRITE:
                            wset.append(s2)

                if s1 is not None:
                    if buf1:
                        wset.append(s1)
                    if s2 is not None and not buf2:
                        rset.append(s1)

                if not rset and not wset:
                    break

                r, w, x = select.select(rset, wset, [])
                if s1 in r:
                    buf2 = s1.recv(1024)
                    if not buf2:
                        s1 = None

                if s1 in w:
                    n = s1.send(buf1)
                    if n > 0:
                        buf1 = buf1[n:]

                if (s2_r in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_ZERO_RETURN) and s2 in r) or\
                   (s2_r in (ssl.SSL_ERROR_WANT_WRITE,) and s2 in w):
                    s2_r = ssl.SSL_ERROR_ZERO_RETURN
                    try:
                        if buf1 := s2.recv(1024):
                            n = s2.pending()
                            while n > 0:
                                buf1 += s2.recv(n)
                                n = s2.pending()
                        else:
                            s2 = None
                    except ssl.SSLError as e:
                        s2_r = e.errno
                        if e.errno not in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_WANT_WRITE):
                            raise
                elif (s2_w in (ssl.SSL_ERROR_WANT_READ,) and s2 in r) or\
                     (s2_w in (ssl.SSL_ERROR_WANT_WRITE, ssl.SSL_ERROR_ZERO_RETURN) and s2 in w):
                    s2_w = ssl.SSL_ERROR_ZERO_RETURN
                    try:
                        n = s2.send(buf2)
                        if n > 0:
                            buf2 = buf2[n:]
                    except ssl.SSLError as e:
                        s2_w = e.errno
                        if e.errno not in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_WANT_WRITE):
                            raise


    class PortForwardingHandler(BaseRequestHandler):
        """ Port Forwarding for the services
        """
        def __init__(
            self,
            request,
            client_address,
            server
        ) -> None:
            self.__remote_host: str = None  # type: ignore
            self.__remote_port: int = None  # type: ignore
            self.__ssl_client_context: ssl.SSLContext = None  # type: ignore
            self.__ssl_server_context: ssl.SSLContext = None  # type: ignore
            self.__local_smtp_port = LOCAL_SMTP_PORT
            self.__local_pop3_port = LOCAL_POP3_PORT
            self.__local_imap4_port = LOCAL_IMAP4_PORT
            self.__local_rainloop_port = LOCAL_RAINLOOP_PORT
            BaseRequestHandler.__init__(self, request, client_address, server)

        def __forward_tcp_tcp(
            self,
            remote_host: str,
            remote_port: int
        ) -> None:
            """  Port Forwarding: TCP <-> TCP(remote host:port)
            """
            cs = self.request
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as rs:
                    rs.settimeout(DEFAULT_SOCKET_TIMEOUT)
                    rs.connect((remote_host, remote_port))
                    ProxyUtils.communicate_tcp_tcp(cs, rs)

            except Exception:
                demisto.debug(traceback.format_exc())
            finally:
                cs.close()

        def __forward_tcp_ssl(
            self,
            remote_host: str,
            remote_port: int,
            preceding_payload: bytes | None = None
        ) -> None:
            """  Port Forwarding: TCP <-> SSL(remote host:port)
            """
            try:
                cs = self.request
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as rlow_socket:
                    with self.__ssl_client_context.wrap_socket(
                        rlow_socket, server_hostname=remote_host) as rs:
                        rs.settimeout(DEFAULT_SOCKET_TIMEOUT)
                        rs.connect((remote_host, remote_port))

                        if preceding_payload is not None:
                            rs.send(preceding_payload)

                        ProxyUtils.communicate_tcp_ssl(cs, rs)

            except Exception:
                demisto.debug(traceback.format_exc())
            finally:
                self.request.close()

        def __forward_ssl_tcp(
            self,
            remote_host: str,
            remote_port: int
        ) -> None:
            """  Port Forwarding: SSL <-> TCP(remote host:port)
            """
            try:
                with self.__ssl_server_context.wrap_socket(self.request, server_side=True) as cs:
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as rs:
                        rs.settimeout(DEFAULT_SOCKET_TIMEOUT)
                        rs.connect((remote_host, remote_port))
                        ProxyUtils.communicate_tcp_ssl(rs, cs)

            except Exception:
                demisto.debug(traceback.format_exc())
            finally:
                self.request.close()

        def setup(
            self
        ) -> None:
            self.__remote_host = self.server.settings.remote_host
            self.__remote_port = self.server.settings.remote_port
            self.__ssl_server_context = self.server.settings.ssl_server_context
            self.__ssl_client_context = self.server.settings.ssl_client_context
            self.__local_smtp_port = self.server.settings.local_smtp_port
            self.__local_pop3_port = self.server.settings.local_pop3_port
            self.__local_imap4_port = self.server.settings.local_imap4_port
            self.__local_rainloop_port = self.server.settings.local_rainloop_port

        def handle(
            self
        ) -> None:
            if self.__remote_host is None:
                remote_host = '127.0.0.1'

                r, _, _ = select.select([self.request], [], [], 1)
                if self.request in r:
                    h = self.request.recv(3, socket.MSG_PEEK)
                    if h[:1] == b'\x16':
                        # TLS
                        self.__forward_ssl_tcp(remote_host, self.__local_imap4_port)
                    elif h[:1] in (b'E', b'e'):
                        # EHLO
                        self.__forward_tcp_tcp(remote_host, self.__local_smtp_port)
                    elif h[:1] in (b'H', b'h'):
                        if h.decode(errors='ignore').upper() == 'HEL':
                            # HELO
                            self.__forward_tcp_tcp(remote_host, self.__local_smtp_port)
                        else:
                            # HEAD or default
                            self.__forward_tcp_tcp(remote_host, self.__local_rainloop_port)
                    else:
                        self.__forward_tcp_tcp(remote_host, self.__local_rainloop_port)
                else:
                    # Client is waiting for SMTP greeting
                    self.__forward_tcp_tcp(remote_host, self.__local_smtp_port)
            else:
                PROTOCOL_ID_RAINLOOP = 0
                PROTOCOL_ID_IMAP4_SSL = 2
                PROTOCOL_ID_SMTP = 3

                r, _, _ = select.select([self.request], [], [], 1)
                if self.request in r:
                    h = self.request.recv(3, socket.MSG_PEEK)
                    if h[:1] == b'\x16':
                        # TLS
                        self.__forward_tcp_ssl(
                            self.__remote_host,
                            self.__remote_port,
                            PROTOCOL_ID_IMAP4_SSL.to_bytes(1, 'big'))
                    elif h[:1] in (b'E', b'e'):
                        # EHLO
                        self.__forward_tcp_ssl(
                            self.__remote_host,
                            self.__remote_port,
                            PROTOCOL_ID_SMTP.to_bytes(1, 'big'))
                    elif h[:1] in (b'H', b'h'):
                        if h.decode(errors='ignore').upper() == 'HEL':
                            # HELO
                            self.__forward_tcp_ssl(
                                self.__remote_host,
                                self.__remote_port,
                                PROTOCOL_ID_SMTP.to_bytes(1, 'big'))
                        else:
                            # HEAD or default
                            self.__forward_tcp_ssl(
                                self.__remote_host,
                                self.__remote_port,
                                PROTOCOL_ID_RAINLOOP.to_bytes(1, 'big'))
                    else:
                        self.__forward_tcp_ssl(
                            self.__remote_host,
                            self.__remote_port,
                            PROTOCOL_ID_RAINLOOP.to_bytes(1, 'big'))
                else:
                    # Client is waiting for SMTP greeting
                    self.__forward_tcp_ssl(
                        self.__remote_host,
                        self.__remote_port,
                        PROTOCOL_ID_SMTP.to_bytes(1, 'big'))

            self.request.close()


    class Service:
        def __init__(
            self,
            settings: Settings
        ) -> None:
            self.__settings = settings
            self.__ssl_client_context: ssl.SSLContext | None = None

        def __gen_self_signed_server_cert(
            self,
            key_size: int
        ) -> Tuple[bytes, bytes]:
            """ Generate a self signed server certificate

            :param key_size: The length of a public key to be generated.
            :return: A certificate and private key pair in PEM
            """
            valid_from = datetime.now()
            valid_until = valid_from + timedelta(1 * 365, 0, 0)

            hostname = socket.gethostname()
            private_key = rsa.generate_private_key(
                public_exponent=65537,
                key_size=key_size,
                backend=default_backend()
            )
            public_key = private_key.public_key()

            builder = x509.CertificateBuilder()
            builder = builder.subject_name(x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, hostname)]))
            builder = builder.issuer_name(x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, hostname)]))
            builder = builder.not_valid_before(valid_from)
            builder = builder.not_valid_after(valid_until)
            builder = builder.serial_number(x509.random_serial_number())
            builder = builder.public_key(public_key)
            builder = builder.add_extension(
                x509.SubjectAlternativeName([
                    x509.DNSName(hostname),
                    x509.DNSName('localhost')
                ]),
                critical=False)
            builder = builder.add_extension(x509.BasicConstraints(ca=False, path_length=None), critical=True)

            certificate = builder.sign(
                private_key=private_key, algorithm=hashes.SHA256(),
                backend=default_backend())

            return (certificate.public_bytes(serialization.Encoding.PEM),
                    private_key.private_bytes(serialization.Encoding.PEM,
                                              serialization.PrivateFormat.PKCS8,
                                              serialization.NoEncryption()))

        def __create_ssl_server_context(
            self
        ) -> ssl.SSLContext:
            """ Create a SSL server context

            :return: a SSL server context
            """
            client_certificate_pem, client_private_key_pem = self.__gen_self_signed_server_cert(DEFAULT_PUBLIC_KEY_SIZE)

            with NamedTemporaryFile(mode='wb') as client_private_key_file:
                client_private_key_file.write(client_private_key_pem)
                client_private_key_file.flush()
                os.fsync(client_private_key_file.fileno())

                with NamedTemporaryFile(mode='wb') as client_certificate_file:
                    client_certificate_file.write(client_certificate_pem)
                    client_certificate_file.flush()
                    os.fsync(client_certificate_file.fileno())

                    ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
                    ssl_ctx.load_cert_chain(
                        certfile=client_certificate_file.name,
                        keyfile=client_private_key_file.name
                    )
                    return ssl_ctx

        def __create_ssl_client_context(
            self
        ) -> ssl.SSLContext:
            """ Create a SSL client context

            :return: a SSL client context
            """
            ssl_ctx = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
            ssl_ctx.load_default_certs()
            ssl_ctx.check_hostname = False
            if self.__settings.insecure:
                ssl_ctx.verify_mode = ssl.CERT_NONE
            else:
                ssl_ctx.verify_mode = ssl.CERT_REQUIRED

            if client_creds := self.__settings.get_client_credentials_pem():
                client_creds_certs_pem, client_creds_pkeys_pem, client_creds_password = client_creds
                with NamedTemporaryFile(mode='w') as pem_certs_file:
                    pem_certs_file.write(client_creds_certs_pem)
                    pem_certs_file.flush()
                    pem_certs_file.seek(0)

                    with NamedTemporaryFile(mode='w') as pem_keys_file:
                        pem_keys_file.write(client_creds_pkeys_pem)
                        pem_keys_file.flush()
                        pem_keys_file.seek(0)
                        ssl_ctx.load_cert_chain(
                            certfile=pem_certs_file.name,
                            keyfile=pem_keys_file.name,
                            password=client_creds_password
                        )
            return ssl_ctx

        def __get_ssl_client_context(
            self
        ) -> ssl.SSLContext:
            """ Get a SSL client context

            :return: a SSL client context
            """
            if self.__ssl_client_context is None:
                self.__ssl_client_context = self.__create_ssl_client_context()
            return self.__ssl_client_context

        def __update_context(
            self
        ) -> Dict[str, Any]:
            """ Store the integration parameters to the integration context.

            :return: The integration context updated.
            """
            x = demisto.getIntegrationContext() or {}
            x['localMailboxPassword'] = self.__settings.local_mailbox_password
            if self.__settings.local_default_admin_password:
                x['localDeafultAdminPassword'] = self.__settings.local_default_admin_password
            elif not x.get('localDeafultAdminPasswordGenerated'):
                # Generate password randomly when the default passwod is not specified
                x['localDeafultAdminPasswordGenerated'] =\
                    ''.join([random.choice(string.ascii_letters + string.digits + '$#!.@+/=_') for i in range(32)])

            demisto.setIntegrationContext(x)
            return x

        def __is_restart_required(
            self
        ) -> bool:
            """ Check if the service restart is required

            :return: True - restart is required.
            """
            if x := demisto.getIntegrationContext():
                if x.get('localMailboxPassword') != self.__settings.local_mailbox_password or\
                   x.get('localDeafultAdminPassword') != self.__settings.local_default_admin_password:
                    return True
            return False

        def get_default_admin_password(
            self
        ) -> str:
            """ Retrieve default admin password

            :return: The default admin password.
            """
            x = self.__update_context()
            return x.get('localDeafultAdminPassword', '') or x.get('localDeafultAdminPasswordGenerated', '')

        def start_services(
            self,
            restart: bool = False
        ) -> None:
            """ Start services

            :param restart: True if it re-starts the service.
            """
            os.environ['SMTP_PORT'] = str(LOCAL_SMTP_PORT)
            os.environ['POP3_PORT'] = str(LOCAL_POP3_PORT)
            os.environ['IMAP4_PORT'] = str(LOCAL_IMAP4_PORT)
            os.environ['RAINLOOP_PORT'] = str(LOCAL_RAINLOOP_PORT)
            os.environ['MAILBOX_PASSWORD'] = self.__settings.local_mailbox_password
            os.environ['RAINLOOP_DEFAULT_ADMIN_PASSWORD'] = self.get_default_admin_password()
            #ret = subprocess.call(['restart.sh' if restart else 'start.sh'])
            #demisto.debug('A {}start command has been requested: {}'.format('re' if restart else '', ret))

            def __start_service(restart):
                ret = subprocess.run(
                    ['restart.sh' if restart else 'start.sh'],
                    capture_output=True)
                demisto.debug('A {}start command has been requested: {}'.format('re' if restart else '', ret.returncode))

            thr = threading.Thread(
                target=__start_service,
                args=(restart,),
                daemon=False)
            thr.start()

        def run_local_server(
            self
        ) -> None:
            """ Run the long running server
            """
            try:
                self.start_services(self.__is_restart_required())
                self.__update_context()

                listen_port = self.__settings.docker_port
                ThreadingTCPServer.allow_reuse_address = True
                with ThreadingTCPServer(('', listen_port), PortForwardingHandler) as server:
                    server.timeout = DEFAULT_SOCKET_TIMEOUT

                    remote_addr = None
                    ssl_client_context = None
                    ssl_server_context = None
                    if self.__settings.is_remote_mode:
                        ssl_client_context = self.__get_ssl_client_context()
                        remote_addr = self.__settings.remote_address
                    else:
                        ssl_server_context = self.__create_ssl_server_context()

                    server.settings = PortForwardingSettings(
                        remote_addr=remote_addr,
                        ssl_server_context=ssl_server_context,
                        ssl_client_context=ssl_client_context
                    )
                    save_port_fowarder_address(None, listen_port)
                    server.serve_forever()
            finally:
                save_port_fowarder_address(None, None)

        def test_server(
            self
        ) -> None:
            if self.__settings.is_remote_mode:
                try:
                    self.test_remote_server()
                except Exception as e:
                    raise DemistoException(f'Failed to test to connect to the remote server - {str(traceback.format_exc())}')
            try:
                self.test_local_server()
            except Exception as e:
                raise DemistoException(f'Failed to test to connect to the local server - {str(traceback.format_exc())}')

        def test_local_server(
            self
        ) -> None:
            """ Test to connect to the local TSRAIN server
            """
            # Restart the services
            self.start_services(True)

            listen_port = self.__settings.docker_port
            try:
                # Start the port forwarder
                ThreadingTCPServer.allow_reuse_address = True
                with ThreadingTCPServer(('', listen_port), PortForwardingHandler) as server:
                    server.timeout = DEFAULT_SOCKET_TIMEOUT
                    server.settings = PortForwardingSettings()
                    server_ip, server_port = server.socket.getsockname()

                    thr = threading.Thread(target=serve_forever, args=(server,), daemon=False)
                    thr.start()
                    try:
                        # Wait for the tsrain services up
                        for _ in range(5):
                            try:
                                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                                    s.settimeout(3.0)
                                    s.connect((server_ip, LOCAL_SMTP_PORT))
                                    if s.recv(1):
                                        break
                            except Exception:
                                time.sleep(2.0)

                        # Wait for the port forwarder up
                        for _ in range(5):
                            try:
                                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                                    s.settimeout(3.0)
                                    s.connect((server_ip, server_port))
                                    if s.recv(1):
                                        break
                            except Exception as e:
                                time.sleep(2.0)

                        # Test SMTP connection
                        with smtplib.SMTP(server_ip, server_port, timeout=DEFAULT_SOCKET_TIMEOUT) as smtp:
                            smtp.quit()
                    except Exception:
                        raise DemistoException(f'Unable to connect to the local server - {server_ip}:{server_port}')
                    finally:
                        server.shutdown()
                        thr.join()
            except Exception as e:
                if 'Address in use' not in str(e):
                    raise

                addrs = [[a['addr'].exploded, listen_port] for a in get_local_addresses()]
                SMTPClient(addrs)

        def test_remote_server(
            self
        ) -> None:
            """ Test to connect to the remote TSRAIN server
            """
            with ThreadingTCPServer(('', 0), PortForwardingHandler) as server:
                server.timeout = DEFAULT_SOCKET_TIMEOUT
                server.settings = PortForwardingSettings(
                    remote_addr=self.__settings.remote_address,
                    ssl_client_context=self.__get_ssl_client_context()
                )
                server_ip, server_port = server.socket.getsockname()

                thr = threading.Thread(target=serve_forever, args=(server,), daemon=False)
                thr.start()
                try:
                    # Test SMTP connection
                    with smtplib.SMTP(server_ip, server_port, timeout=DEFAULT_SOCKET_TIMEOUT) as smtp:
                        smtp.quit()
                finally:
                    server.shutdown()
                    thr.join()

        def send_mail(
            self,
            msg: Union[str, email.message.Message],
            mail_from: str,
            rcpt_to: List[str]
        ) -> None:
            """ Send an email message

            :param msg: The email message to send
            :param mail_from: The sender address
            :param rcpt_to: The list of recipient addresses
            """
            if self.__settings.is_remote_mode:
                with ThreadingTCPServer(('', 0), PortForwardingHandler) as server:
                    server.timeout = DEFAULT_SOCKET_TIMEOUT
                    server.settings = PortForwardingSettings(
                        remote_addr=self.__settings.remote_address,
                        ssl_client_context=self.__get_ssl_client_context()
                    )
                    server_ip, server_port = server.socket.getsockname()

                    thr = threading.Thread(
                        target=serve_forever,
                        args=(server,),
                        daemon=False
                    )
                    thr.start()

                    # Send an email message
                    smtp = SMTPClient([(server_ip, server_port)])
                    smtp.send_message(msg, mail_from, rcpt_to)
                    smtp.quit()

                    server.shutdown()
                    thr.join()
            else:
                smtp = SMTPClient(get_port_fowarder_addresses())
                smtp.send_message(msg, mail_from, rcpt_to)
                smtp.quit()


    class SMTPClient:
        def __init__(
            self,
            addrs: List[Tuple[str, int]]
        ) -> None:
            """ Initialize a SMTP client instance

            :param addrs: The list of SMTP server addresses to try to connect
            """
            for host, port in addrs:
                try:
                    self.__sess = smtplib.SMTP(host, port, timeout=DEFAULT_SOCKET_TIMEOUT)
                except Exception:
                    continue
                break
            else:
                raise DemistoException(f'Unable to connect to any SMTP server addresses - {addrs}')

        def send_message(
            self,
            msg: Union[str, email.message.Message],
            from_addr: str,
            to_addrs: List[str]
        ) -> None:
            """ Send an email message

            :param msg: An email message
            :param from_addr: The sender address
            :param to_addrs: List of recipient addresses
            """
            if isinstance(msg, email.message.Message):
                self.__sess.send_message(
                    msg,
                    from_addr=from_addr,
                    to_addrs=to_addrs
                )
            else:
                self.__sess.sendmail(from_addr, to_addrs, msg)

        def quit(self) -> None:
            self.__sess.quit()


    class MessageBuilder:
        @staticmethod
        def __guess_file_type(
            filename: str
        ) -> Tuple[str, str]:
            """
            Return the maintype and subtype guessed based on the extension
            """
            ctype, encoding = mimetypes.guess_type(filename)
            if ctype is None or encoding is not None:
                # No guess could be made, or the file is encoded (compressed), so
                # use a generic bag-of-bits type.
                ctype = 'application/octet-stream'
            main_type, _, sub_type = ctype.partition('/')
            return main_type, sub_type

        @staticmethod
        def __build_attachment_message(
            file_name: str,
            file_data: Union[str, bytes],
            main_type: str,
            sub_type: str,
            content_id: str | None
        ) -> MIMEBase:
            """ Create an attachment email entity

            :param file_name: The file name
            :param file_data: The data of the file
            :param main_type: The primary content type
            :param sub_type: The content sub type
            :param content_id: The content ID to set to Content-ID
            :return An attachment email entity created.
            """
            if main_type == 'text':
                # UTF-8 is a pretty safe bet
                if isinstance(file_data, bytes):
                    file_data = file_data.decode('utf-8', errors='ignore')
                attachment: MIMEBase = MIMEText(file_data, sub_type, 'utf-8')
            elif main_type == 'image':
                attachment = MIMEImage(file_data, sub_type)
            elif main_type == 'audio':
                attachment = MIMEAudio(file_data, sub_type)
            elif main_type == 'message':
                attachment = MIMEBase(main_type, sub_type)
                attachment.set_payload(file_data)
            else:
                attachment = MIMEBase(main_type, sub_type)
                attachment.set_payload(file_data)
                # Encode the payload using Base64
                email.encoders.encode_base64(attachment)

            # Set the filename parameter
            if content_id:
                attachment.add_header('Content-Disposition', 'inline', filename=file_name)
                attachment.add_header('Content-ID', f'<{content_id}>')
            else:
                attachment.add_header('Content-Disposition', 'attachment', filename=file_name)
            return attachment

        @staticmethod
        def __build_html_messages(
            html: str
        ) -> Tuple[str, List[MIMEBase]]:
            """ Extract all data-url content from within the html and return as separate attachments

                Due to security implications, we support only images here
                We might not have Beautiful Soup so just do regex search

            :param html: The HTML text
            :return An html text and images.
            """
            def _random_word(length):
                """
                Generate a random string of given length
                """
                letters = string.ascii_lowercase
                return ''.join(random.choice(letters) for i in range(length))

            attachments = []
            clean_body = ''
            last_index = 0
            for i, m in enumerate(
                    re.finditer(r'<img.+?src=\"(data:(image\/.+?);base64,([a-zA-Z0-9+/=\r\n]+?))\"', html, re.I)):
                main_type, sub_type = m.group(2).split('/', 1)
                file_name = f'image{i}.{sub_type}'
                content_id = f'{file_name}{_random_word(8)}.{_random_word(8)}'

                attachment = MessageBuilder.__build_attachment_message(
                    file_name=file_name,
                    file_data=base64.b64decode(m.group(3)),
                    main_type=main_type,
                    sub_type=sub_type,
                    content_id=content_id
                )
                attachments.append(attachment)

                clean_body += html[last_index:m.start(1)] + 'cid:' + content_id
                last_index = m.end() - 1
            clean_body += html[last_index:]
            return clean_body, attachments

        def __init__(
            self
        ) -> None:
            self.__from: str | None = None
            self.__to: List[str] = []
            self.__cc: List[str] = []
            self.__bcc: List[str] = []
            self.__reply_to: str | None = None
            self.__in_reply_to: str | None = None
            self.__body: str | None = None
            self.__html_body: str | None = None
            self.__subject: str | None = None
            self.__headers: List[str] = []
            self.__attachments: List[MIMEBase] = []
            self.__template_params: Dict[str, str] = {}

        def set_from(
            self,
            address: str | None
        ) -> None:
            self.__from = address

        def set_to(
            self,
            addresses: List[str] | None
        ) -> None:
            self.__to = addresses or list()

        def set_cc(
            self,
            addresses: List[str] | None
        ) -> None:
            self.__cc = addresses or list()

        def set_bcc(
            self,
            addresses: List[str] | None
        ) -> None:
            self.__bcc = addresses or list()

        def set_reply_to(
            self,
            address: str | None
        ) -> None:
            self.__reply_to = address

        def set_in_reply_to(
            self,
            in_reply_to: str | None
        ) -> None:
            self.__in_reply_to = in_reply_to

        def set_subject(
            self,
            subject: str | None
        ) -> None:
            self.__subject = subject

        def set_body(
            self,
            body: str | None
        ) -> None:
            self.__body = body

        def set_html_body(
            self,
            html_body: str | None
        ) -> None:
            self.__html_body = html_body

        def set_additional_headers(
            self,
            headers: List[str] | None
        ) -> None:
            self.__headers = headers or list()

        def set_template_params(
            self,
            template: Union[str, Dict[str, Dict[str, str]]] | None
        ) -> None:
            """ Set template parameters

            :param template: The template parameters
            """
            self.__template_params = {}
            if not template:
                return

            if isinstance(template, dict):
                params = template
            else:
                try:
                    params = json.loads(template)
                except json.decoder.JSONDecodeError as e:
                    raise DemistoException(f'Unable to parse templateParams: {str(e)}')

            context = demisto.context()
            for k, ent in params.items():
                if value := ent.get('value'):
                    self.__template_params[k] = value
                elif key := ent.get('key'):
                    self.__template_params[k] = demisto.dt(context, key)

        def add_attachment_file_by_entry_id(
            self,
            entity_id: str,
            file_name: str | None,
            content_id: str | None
        ) -> None:
            """ Add an attachment file by an entry ID

            :param entry_id: The entry ID of the file
            :param file_name: The file name
            :param content_id: The content ID to set to Content-ID
            """
            try:
                file_res = demisto.getFilePath(entity_id)
                file_path = file_res['path']
                file_name = file_name or file_res['name']

                main_type, sub_type = MessageBuilder.__guess_file_type(file_name)
                with open(file_path, 'r' if main_type == 'text' else 'rb') as f:
                    file_data = f.read()

                attachment = MessageBuilder.__build_attachment_message(
                    file_name=file_name,
                    file_data=file_data,
                    main_type=main_type,
                    sub_type=sub_type,
                    content_id=content_id or ''
                )
                self.__attachments.append(attachment)
            except Exception as e:
                demisto.error(f'Invalid entry {entity_id} with exception: {str(e)}')
                raise DemistoException(f'Entry {entity_id} is not valid or is not a file entry')

        def add_attachment_file_by_data(
            self,
            file_name: str,
            file_data: Union[str, bytes],
            content_id: str | None
        ) -> None:
            """ Add an attachment file by a payload

            :param file_name: The file name
            :param file_data: The payload of the file
            :param content_id: The content ID to set to Content-ID
            """
            main_type, sub_type = MessageBuilder.__guess_file_type(file_name)
            attachment = MessageBuilder.__build_attachment_message(
                file_name=file_name,
                file_data=file_data,
                main_type=main_type,
                sub_type=sub_type,
                content_id=content_id or ''
            )
            self.__attachments.append(attachment)

        def build(
            self
        ) -> email.message.Message:
            """ Build an email message

            :return: The email message.
            """
            def _new_header(s) -> Optional[email.header.Header]:
                return email.header.Header(' '.join(s.splitlines()), 'utf-8') if s else None

            # Basic validation - we allow pretty much everything but you have to have at least a recipient
            # We allow messages without subject and also without body
            if not self.__to and not self.__cc and not self.__bcc:
                raise DemistoException('You must have at least one recipient')

            if not self.__from:
                raise DemistoException('You must have an sender address')

            attachments = list(self.__attachments)
            body = self.__body or ''
            html_body = self.__html_body or ''
            if self.__template_params:
                body = body.format(**self.__template_params)
                html_body = html_body.format(**self.__template_params)

            # Let's see what type of message we are talking about
            if not html_body:
                # This is a simple text message - we cannot have CIDs here
                if len(attachments) > 0:
                    # This is multipart - default is mixed
                    msg: MIMEBase = MIMEMultipart()
                    msg.preamble = 'The message is only available on a MIME-aware mail reader.\n'
                    msg.attach(MIMEText(body, 'plain', 'utf-8'))
                    for attachment in attachments:
                        del attachment['Content-ID']
                        msg.attach(attachment)
                else:
                    # Just text, how boring
                    msg = MIMEText(body, 'plain', 'utf-8')
            else:
                html_body, html_attachments = MessageBuilder.__build_html_messages(html_body)
                attachments.extend(html_attachments)
                if len(attachments) > 0:
                    msg = MIMEMultipart()
                    msg.preamble = 'The message is only available on a MIME-aware mail reader.\n'
                    if body:
                        alt = MIMEMultipart('alternative')
                        alt.attach(MIMEText(body, 'plain', 'utf-8'))
                        alt.attach(MIMEText(html_body, 'html', 'utf-8'))
                        msg.attach(alt)
                    else:
                        msg.attach(MIMEText(html_body, 'html', 'utf-8'))
                    for attachment in attachments:
                        msg.attach(attachment)
                else:
                    if body:
                        msg = MIMEMultipart('alternative')
                        msg.preamble = 'The message is only available on a MIME-aware mail reader.\n'
                        msg.attach(MIMEText(body, 'plain', 'utf-8'))
                        msg.attach(MIMEText(html_body, 'html', 'utf-8'))
                    else:
                        msg = MIMEText(html_body, 'html', 'utf-8')

            # Add the relevant headers to the most outer message
            msg['Subject'] = _new_header(self.__subject or '')
            msg['From'] = _new_header(self.__from)
            if self.__reply_to:
                msg['Reply-To'] = _new_header(self.__reply_to)
            if self.__to:
                msg['To'] = _new_header(','.join(self.__to))
            if self.__cc:
                msg['CC'] = _new_header(','.join(self.__cc))
            if self.__bcc:
                msg['BCC'] = _new_header(','.join(self.__bcc))
            if self.__in_reply_to:
                msg['In-Reply-To'] = _new_header(self.__in_reply_to)

            for h in self.__headers:
                name, value = h.split('=', 1)
                msg[name] = _new_header(value)

            return msg


    ''' COMMAND FUNCTIONS '''


    def test_module(
        args: Dict[str, Any]
    ) -> Tuple[str, Dict[str, Any], Dict[str, Any]]:
        """ Validates server settings

        :param args: The argument parameters
        """
        run_long_running(is_test=True)
        return 'ok', {}, {}


    def get_servcie_info_command(
        args: Dict[str, Any]
    ) -> Tuple[str, Dict[str, Any], Dict[str, Any]]:
        """ Get the service information

        :param args: The argument parameters
        """
        sinfo = []

        x = demisto.getIntegrationContext() or {}
        if addrs := x.get('PortForwarderAddresses'):
            # Service is running
            sinfo = []
            for a in json.loads(addrs):
                service_host = a['Host']
                service_port = int(a['Port'])
                status = 'Not Running'
                try:
                    with smtplib.SMTP(service_host, service_port, timeout=3) as smtp:
                        smtp.quit()
                        status = 'Running'
                except Exception:
                    pass

                sinfo.append({
                    'IP': service_host,
                    'Port': service_port,
                    'Instance': demisto.integrationInstance(),
                    'Status': status
                })
        else:
            # Service is not running
            for ai in get_local_addresses():
                ip = str(ai['addr'])
                if ip not in ('127.0.0.1'):
                    sinfo.append({
                        'IP': ip,
                        'Name': demisto.integrationInstance(),
                        'Status': 'Not Running'
                    })

        if not sinfo:
            return 'Unable to get the service information', {}, {}

        hr = tblToMd('Service', sinfo)
        return hr, {'TsrainCompact.Service': sinfo}, sinfo


    def get_gateways_command(
        args: Dict[str, Any]
    ) -> Tuple[str, Dict[str, Any], Dict[str, Any]]:
        """ Get gateway list

        :param args: The argument parameters
        """
        if ifs := get_gateway_interfaces():
            hr = tblToMd('Gateways', ifs)
            return hr, {'TsrainCompact.GW': ifs}, ifs
        else:
            hr = 'No gateway addresses'
            return hr, {}, []


    def get_default_admin_password_command(
        args: Dict[str, Any]
    ) -> Tuple[str, Dict[str, Any], Dict[str, Any]]:
        """ Get default admin password

        :param args: The argument parameters
        """
        pwd = Service(settings=SETTINGS).get_default_admin_password()
        return f'admin password: {pwd}', {}, pwd


    def restart_command(
        args: Dict[str, Any]
    ) -> Tuple[str, Dict[str, Any], Dict[str, Any]]:
        """ Restart the core service

        :param args: The argument parameters
        """
        Service(settings=SETTINGS).start_services(True)
        return 'The services have been restarted.', {}, {}


    def send_eml_command(
        args: Dict[str, Any]
    ) -> Tuple[str, Dict[str, Any], Dict[str, Any]]:
        """ Send an email message

        :param args: The argument parameters
        """
        entry_id = args.get('entry_id')
        eml_file = demisto.getFilePath(entry_id)
        with open(eml_file['path'], 'r') as f:
            msg = email.parser.Parser().parse(f)

        senders = extract_email_addresses([args.get('sender') or SETTINGS.sender_email_address or ''])
        if not senders or not senders[0]:
            senders = extract_email_addresses(msg.get_all('Sender', []) + msg.get_all('From', []))  # type: ignore
            if not senders or not senders[0]:
                raise DemistoException('You must have an sender address')
        mail_from = senders[0]

        if not (rcpt_to := extract_email_addresses(argToList(args.get('recipients')))):
            recipients: List[Any] = msg.get_all('To', []) + msg.get_all('Cc', []) + msg.get_all('Bcc', [])
            if not (rcpt_to := extract_email_addresses(recipients)):
                raise DemistoException('You must have at least one recipient')
        rcpt_to = list(set(rcpt_to))

        del msg['Bcc']
        del msg['Resent-Bcc']
        del msg['Date']
        msg['Date'] = email.utils.formatdate(time.mktime(datetime.now().timetuple()), usegmt=True)

        header = args.get('add_headers') or {}
        if isinstance(header, str):
            header = json.loads(header)
        if not isinstance(header, dict):
            raise DemistoException('header must be dict, or str in JSON dict')

        for name, value in header.items():
            msg[name] = value

        header = args.get('replace_headers') or {}
        if isinstance(header, str):
            header = json.loads(header)
        if not isinstance(header, dict):
            raise DemistoException('header must be dict, or str in JSON dict')

        for name, value in header.items():
            del msg[name]
            msg[name] = value

        for name in argToList(args.get('remove_headers') or []):
            del msg[name]

        # Send an email message
        Service(settings=SETTINGS).send_mail(msg, mail_from, rcpt_to)

        return 'An email has been sent successfully', {}, {}


    def send_mail_command(
        args: Dict[str, Any]
    ) -> Tuple[str, Dict[str, Any], Dict[str, Any]]:
        """ Send an email message

        :param args: The argument parameters
        """
        if 'send-mail' not in SETTINGS.active_shared_commands:
            return 'send-mail command is disabled', {}, {}

        sender = args.get('from') or SETTINGS.sender_email_address or ''
        if not (senders := extract_email_addresses([sender])) or not senders[0]:
            raise DemistoException('You must have an sender address')
        mail_from = senders[0]

        to = argToList(args.get('to'))
        cc = argToList(args.get('cc'))
        bcc = argToList(args.get('bcc'))
        if not (rcpt_to := extract_email_addresses(to + cc + bcc)):
            raise DemistoException('You must have at least one recipient')
        rcpt_to = list(set(rcpt_to))

        reply_to = args.get('replyTo') or args.get('reply_to') or None

        if raw_message := args.get('raw_message'):
            msg: Union[str, email.message.Message] = raw_message
        else:
            # Build an email message
            body = args.get('body')
            body_html = args.get('htmlBody')
            body_type = args.get('body_type') or 'text'
            if body_type == 'HTML':
                if not body_html:
                    body_html = body
                    body = None
            elif body_type != 'text':
                raise DemistoException(f'Invalid body_type: {body_type}')

            builder = MessageBuilder()
            builder.set_from(sender)
            builder.set_to(to)
            builder.set_cc(cc)
            builder.set_bcc(bcc)
            builder.set_reply_to(reply_to)
            builder.set_subject(args.get('subject'))
            builder.set_body(body)
            builder.set_html_body(body_html)
            builder.set_additional_headers(argToList(args.get('additionalHeader')))
            builder.set_template_params(args.get('templateParams'))

            # Attachment files
            for aid, name, cid in zip_longest(
                    argToList(args.get('attachIDs')),
                    argToList(args.get('attachNames')),
                    argToList(args.get('attachCIDs'))):
                if aid:
                    builder.add_attachment_file_by_entry_id(aid, name, cid)
            for aid, name, cid in zip_longest(
                    argToList(args.get('attach_ids')),
                    argToList(args.get('attach_names')),
                    argToList(args.get('attach_cids'))):
                if aid:
                    builder.add_attachment_file_by_entry_id(aid, name, cid)

            # Transient files
            t_names = args.get('transientFile', [])
            t_names = t_names if isinstance(t_names, (list, tuple)) else t_names.split(',')
            t_contents = args.get('transientFileContent', [])
            t_contents = t_contents if isinstance(t_contents, (list, tuple)) else t_contents.split(',')
            t_cids = args.get('transientFileCID', [])
            t_cids = t_cids if isinstance(t_cids, (list, tuple)) else t_cids.split(',')
            for name, data, cid in zip_longest(t_names, t_contents, t_cids):
                if not name or not data:
                    break
                builder.add_attachment_file_by_data(name, data, cid)
            msg = builder.build()

        # Send an email message
        Service(settings=SETTINGS).send_mail(msg, mail_from, rcpt_to)

        return 'An email has been sent successfully', {}, {}


    def reply_mail_command(
        args: Dict[str, Any]
    ) -> Tuple[str, Dict[str, Any], Dict[str, Any]]:
        """ Reply an email message

        :param args: The argument parameters
        """
        if 'reply-mail' not in SETTINGS.active_shared_commands:
            return 'reply-mail command is disabled', {}, {}

        sender = args.get('from') or SETTINGS.sender_email_address or ''
        if not (senders := extract_email_addresses([sender])) or not senders[0]:
            raise DemistoException('You must have an sender address')
        mail_from = senders[0]

        to = argToList(args.get('to'))
        cc = argToList(args.get('cc'))
        bcc = argToList(args.get('bcc'))
        if not (rcpt_to := extract_email_addresses(to + cc + bcc)):
            raise DemistoException('You must have at least one recipient')
        rcpt_to = list(set(rcpt_to))

        reply_to = args.get('replyTo') or args.get('reply_to') or None
        in_reply_to = args.get('inReplyTo')

        # Build an email message
        body = args.get('body')
        body_html = args.get('htmlBody')
        body_type = args.get('body_type') or 'text'
        if body_type == 'HTML':
            if not body_html:
                body_html = body
                body = None
        elif body_type != 'text':
            raise DemistoException(f'Invalid body_type: {body_type}')

        builder = MessageBuilder()
        builder.set_from(sender)
        builder.set_to(to)
        builder.set_cc(cc)
        builder.set_bcc(bcc)
        builder.set_reply_to(reply_to)
        builder.set_in_reply_to(in_reply_to)
        builder.set_subject(args.get('subject'))
        builder.set_body(body)
        builder.set_html_body(body_html)
        builder.set_additional_headers(argToList(args.get('additionalHeader')))
        builder.set_template_params(args.get('templateParams'))

        # Attachment files
        for aid, name, cid in zip_longest(
                argToList(args.get('attachIDs')),
                argToList(args.get('attachNames')),
                argToList(args.get('attachCIDs'))):
            if aid:
                builder.add_attachment_file_by_entry_id(aid, name, cid)
        for aid, name, cid in zip_longest(
                argToList(args.get('attach_ids')),
                argToList(args.get('attach_names')),
                argToList(args.get('attach_cids'))):
            if aid:
                builder.add_attachment_file_by_entry_id(aid, name, cid)

        # Transient files
        t_names = args.get('transientFile', [])
        t_names = t_names if isinstance(t_names, (list, tuple)) else t_names.split(',')
        t_contents = args.get('transientFileContent', [])
        t_contents = t_contents if isinstance(t_contents, (list, tuple)) else t_contents.split(',')
        t_cids = args.get('transientFileCID', [])
        t_cids = t_cids if isinstance(t_cids, (list, tuple)) else t_cids.split(',')
        for name, data, cid in zip_longest(t_names, t_contents, t_cids):
            if not name or not data:
                break
            builder.add_attachment_file_by_data(name, data, cid)
        msg = builder.build()

        # Send an email message
        Service(settings=SETTINGS).send_mail(msg, mail_from, rcpt_to)

        return 'An email has been sent successfully', {}, {}


    def run_long_running(
        is_test=False
    ) -> None:
        """ Start the long running server

        :param is_test: Indicates whether it's test-module run or regular run
        """
        try:
            listen_port = SETTINGS.docker_port
            if listen_port <= 0:
                raise ValueError(f'Invalid long running port: {listen_port}')
            if listen_port < 1024 or listen_port in (LOCAL_SMTP_PORT, LOCAL_POP3_PORT, LOCAL_IMAP4_PORT, LOCAL_RAINLOOP_PORT):
                raise ValueError(f'Listen ports less than 1024, {LOCAL_SMTP_PORT},'
                                 f' {LOCAL_POP3_PORT}, {LOCAL_IMAP4_PORT}'
                                 f' and {LOCAL_RAINLOOP_PORT} are reserved for system: {listen_port}')

            service = Service(settings=SETTINGS)
            if is_test:
                service.test_server()
            else:
                service.run_local_server()

        except Exception as e:
            demisto.error(f'An error occurred in long running loop: {str(e)}')
            raise DemistoException(str(e))


    def main():
        """ Main
        """
        command = demisto.command()
        demisto.debug('Command being called is {}'.format(command))
        commands = {
            'test-module': test_module,
            'tsrc-get-service-info': get_servcie_info_command,
            'tsrc-get-gateways': get_gateways_command,
            'tsrc-get-default-admin-password': get_default_admin_password_command,
            'tsrc-restart': restart_command,
            'tsrc-send-eml': send_eml_command,
            'send-mail': send_mail_command,
            'reply-mail': reply_mail_command,
        }
        try:
            if command == 'long-running-execution':
                run_long_running()
            else:
                args = assign_params(**demisto.args())
                readable_output, outputs, raw_response = commands[command](args)
                return_outputs(readable_output, outputs, raw_response)
        except Exception as e:
            err_msg = f'Error in {INTEGRATION_NAME} Integration [{e}]'
            return_error(err_msg)


    if __name__ in ['__main__', '__builtin__', 'builtins']:
        main()
  type: python
  commands:
  - name: tsrc-get-service-info
    arguments: []
    outputs:
    - contextPath: TsrainCompact.Service.IP
      description: The IP address on which the service is running
      type: string
    - contextPath: TsrainCompact.Service.Name
      description: The instance name of the service
      type: string
    - contextPath: TsrainCompact.Service.Port
      description: The port number on which the service is running
    - contextPath: TsrainCompact.Service.Status
      description: The service status
    description: Get the service information
  - name: tsrc-get-default-admin-password
    arguments: []
    description: Print default 'admin' password
  - name: tsrc-restart
    arguments: []
    description: Restart the services
  - name: tsrc-get-gateways
    arguments: []
    outputs:
    - contextPath: TsrainCompact.GW.IP
      description: The IP address of the gateway
      type: string
    - contextPath: TsrainCompact.GW.Interface
      description: The interface name
      type: string
    - contextPath: TsrainCompact.GW.Default
      description: True if the IP is Default gateway
      type: boolean
    description: Get gateway addresses of the instance running
  - name: tsrc-send-eml
    arguments:
    - name: entry_id
      required: true
      description: An entry ID of .eml file for an email to be sent
    - name: sender
      description: An email address of sender
    - name: recipients
      description: A comma-separated list of email address of recipients
    - name: replace_headers
      description: The header fields that overrides the header of .eml (in JSON dictionary)
    - name: add_headers
      description: The header fields to add to the header of .eml (in JSON dictionary)
    - name: remove_headers
      description: The list of header names to remove from the eml
    description: Send an email of .eml file
  - name: send-mail
    arguments:
    - name: from
      description: The email address from which to reply.
    - name: to
      default: true
      description: A comma-separated list of email addresses for the 'to' field.
      isArray: true
    - name: cc
      description: A comma-separated list of email addresses for the 'cc' field.
      isArray: true
    - name: bcc
      description: A comma-separated list of email addresses for the 'bcc' field.
      isArray: true
    - name: subject
      description: Subject for the email to be sent
    - name: body
      description: The contents (body) of the email to be sent in plain text
    - name: body_type
      auto: PREDEFINED
      predefined:
      - text
      - HTML
      description: 'The body type of the email. Can be: "text", or "HTML".'
    - name: htmlBody
      description: The contents (body) of the email to be sent in HTML format
    - name: replyTo
      description: Address that should be used to reply to the message
    - name: attachIDs
      description: A comma-separated list of IDs of war room entries that contain
        the files that should be attached to the email
      isArray: true
    - name: attachNames
      description: A comma-separated list to rename file-names of corresponding attachments
        IDs. (e.g. rename first two files - attachNames=file_name1,file_name2. rename
        first and third file - attachNames=file_name1,,file_name3)
      isArray: true
    - name: attachCIDs
      description: A comma-separated list of CIDs to embed attachments inside the
        email itself
      isArray: true
    - name: attach_ids
      description: A comma-separated list of IDs of war room entries that contain
        the files that should be attached to the email
      isArray: true
    - name: attach_names
      description: A comma-separated list to rename file-names of corresponding attachments
        IDs. (e.g. rename first two files - attachNames=file_name1,file_name2. rename
        first and third file - attachNames=file_name1,,file_name3)
      isArray: true
    - name: attach_cids
      description: A comma-separated list of CIDs to embed attachments inside the
        email itself
      isArray: true
    - name: transientFile
      description: Desired name for attached file. Multiple files are supported as
        comma-separated list. (e.g. transientFile="t1.txt,temp.txt,t3.txt" transientFileContent="test
        2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz")
      isArray: true
    - name: transientFileContent
      description: Content for attached file. Multiple files are supported as comma-separated
        list. (e.g. transientFile="t1.txt,temp.txt,t3.txt" transientFileContent="test
        2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz")
      isArray: true
    - name: transientFileCID
      description: CID for attached file if we want it inline. Multiple files are
        supported as comma-separated list. (e.g. transientFile="t1.txt,temp.txt,t3.txt"
        transientFileContent="test 2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz")
      isArray: true
    - name: templateParams
      description: 'Replace {varname} variables with values from this argument. Expected
        values are in the form of a JSON document like {"varname": {"value": "some
        value", "key": "context key"}}. Each var name can either be provided with
        the value or a context key to retrieve the value from. Note that only context
        data is accessible for this argument, while incident fields are not.'
    - name: additionalHeader
      description: 'A CSV list of additional headers in the format: headerName=headerValue.
        For example: "headerName1=headerValue1,headerName2=headerValue2".'
      isArray: true
    - name: raw_message
      description: Raw email message to send. If provided, all other arguments, but
        to, cc and bcc, will be ignored.
    description: Send an email
  - name: reply-mail
    arguments:
    - name: from
      description: The email address from which to reply.
    - name: to
      required: true
      default: true
      description: A comma-separated list of email addresses for the 'to' field.
      isArray: true
    - name: cc
      description: A comma-separated list of email addresses for the 'cc' field.
      isArray: true
    - name: bcc
      description: A comma-separated list of email addresses for the 'bcc' field.
      isArray: true
    - name: inReplyTo
      required: true
      description: ID of the email to reply to.
    - name: subject
      description: Subject for the email to be sent
    - name: body
      description: The contents (body) of the email to be sent in plain text
    - name: body_type
      auto: PREDEFINED
      predefined:
      - text
      - HTML
      description: 'The body type of the email. Can be: "text", or "HTML".'
    - name: htmlBody
      description: The contents (body) of the email to be sent in HTML format
    - name: replyTo
      description: Address that should be used to reply to the message
    - name: attachIDs
      description: A comma-separated list of IDs of war room entries that contain
        the files that should be attached to the email
      isArray: true
    - name: attachNames
      description: A comma-separated list to rename file-names of corresponding attachments
        IDs. (e.g. rename first two files - attachNames=file_name1,file_name2. rename
        first and third file - attachNames=file_name1,,file_name3)
      isArray: true
    - name: attachCIDs
      description: A comma-separated list of CIDs to embed attachments inside the
        email itself
      isArray: true
    - name: attach_ids
      description: A comma-separated list of IDs of war room entries that contain
        the files that should be attached to the email
      isArray: true
    - name: attach_names
      description: A comma-separated list to rename file-names of corresponding attachments
        IDs. (e.g. rename first two files - attachNames=file_name1,file_name2. rename
        first and third file - attachNames=file_name1,,file_name3)
      isArray: true
    - name: attach_cids
      description: A comma-separated list of CIDs to embed attachments inside the
        email itself
      isArray: true
    - name: transientFile
      description: Desired name for attached file. Multiple files are supported as
        comma-separated list. (e.g. transientFile="t1.txt,temp.txt,t3.txt" transientFileContent="test
        2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz")
      isArray: true
    - name: transientFileContent
      description: Content for attached file. Multiple files are supported as comma-separated
        list. (e.g. transientFile="t1.txt,temp.txt,t3.txt" transientFileContent="test
        2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz")
      isArray: true
    - name: transientFileCID
      description: CID for attached file if we want it inline. Multiple files are
        supported as comma-separated list. (e.g. transientFile="t1.txt,temp.txt,t3.txt"
        transientFileContent="test 2,temporary file content,third file content" transientFileCID="t1.txt@xxx.yyy,t2.txt@xxx.zzz")
      isArray: true
    - name: templateParams
      description: 'Replace {varname} variables with values from this argument. Expected
        values are in the form of a JSON document like {"varname": {"value": "some
        value", "key": "context key"}}. Each var name can either be provided with
        the value or a context key to retrieve the value from. Note that only context
        data is accessible for this argument, while incident fields are not.'
    - name: additionalHeader
      description: 'A CSV list of additional headers in the format: headerName=headerValue.
        For example: "headerName1=headerValue1,headerName2=headerValue2".'
      isArray: true
    - name: raw_message
      description: Raw email message to send. If provided, all other arguments, but
        to, cc and bcc, will be ignored.
    description: Reply to an email
  dockerimage: spearmint/xsoar-tsrain:5.9.3.0019
  longRunning: true
  longRunningPort: true
  subtype: python3
sourcemoduleid: ExportIndicators
