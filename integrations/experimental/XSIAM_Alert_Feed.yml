commonfields:
  id: XSIAM Alert Feed
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: XSIAM Alert Feed
display: XSIAM Alert Feed
category: Utilities
image: data:image/png;base64,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eG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOmMzZTIzMWJlLWRmNzktNDE1NS1hNmVjLWYzNTI0M2FiMjI2NSIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3YzNmZGJlNi1kMjk5LTRiZjEtODJmMC1mZTM3OGYyY2Y1YjEiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozNDVlMzA5Ny0wZTRlLTQ3ZjUtYTJlNi1jMDFkMmJiMTM3MGIiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJXaW5kb3dzIgogICBHSU1QOlRpbWVTdGFtcD0iMTcxNTE0OTYwMTQzMzQ1NCIKICAgR0lNUDpWZXJzaW9uPSIyLjEwLjMyIgogICB0aWZmOk9yaWVudGF0aW9uPSIxIgogICB4bXA6Q3JlYXRvclRvb2w9IkdJTVAgMi4xMCIKICAgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyNDowNTowOFQxNToyNjozOSswOTowMCIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjQ6MDU6MDhUMTU6MjY6MzkrMDk6MDAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDoyY2Y4NTY3NS0wMzEyLTRjYTQtOTVmNy03NDMwYmI1MWY3ODkiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjQtMDUtMDhUMTU6MjY6NDEiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg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
description: Insert alerts from JSON to XSIAM/XDR
configuration:
- display: The base URL of the XSIAM API endpoints
  name: xsiam_api_url
  type: 0
  required: true
- display: XSIAM API ID
  displaypassword: XSIAM API Key
  name: xsiam_credentials
  type: 9
  required: true
- display: XSIAM API Key Type
  name: xsiam_apikey_type
  defaultvalue: Advanced
  type: 15
  required: false
  options:
  - Standard
  - Advanced
- section: Connect
  advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  type: 8
  required: false
- section: Connect
  advanced: true
  display: Use system proxy settings
  name: proxy
  type: 8
  required: false
- section: Collect
  display: Fetch incidents
  name: isFetch
  type: 8
  required: false
- section: Connect
  display: Incident type
  name: incidentType
  type: 13
  required: false
- display: Alerts to insert_parsed_alerts
  name: parsed_alerts
  type: 12
  required: false
- display: Number of templates to feed alerts in fetch cycle
  name: number_of_templates
  type: 0
  required: false
- display: Number of clones for each alert
  name: number_of_clones
  defaultvalue: "1"
  type: 0
  required: false
- display: Choose alerts randomly
  name: random_choices
  defaultvalue: "false"
  type: 8
  required: false
- display: Incidents Fetch Interval
  name: incidentFetchInterval
  defaultvalue: "1"
  type: 19
  required: false
script:
  script: |
    register_module_line('XSIAM Alert Feed', 'start', __line__())


    ''' IMPORTS '''
    from enum import Enum
    from typing import Any, List, Tuple, Iterator
    from datetime import datetime
    import re
    import math
    import secrets
    import string
    import hashlib
    import random
    import ipaddress
    import dateparser


    NUMBER_OF_CLONES_FOR_EACH_TEMPLATE = 1
    NUMBER_OF_ALERTS_IN_INSERT_PARSED_ALERTS_API = 60


    ''' HELPER FUNCTIONS '''
    def get_parsed_alerts_template(
        params: dict[str, Any]
    ) -> list[dict[str, Any]]:
        """ Get the template of parsed alerts

        :param params: Instance configuration parameters
        :return: Template of parsed alerts.
        """
        parsed_alerts = params.get('parsed_alerts') or []
        if isinstance(parsed_alerts, str):
            parsed_alerts = json.loads(parsed_alerts)
        if isinstance(parsed_alerts, dict):
            parsed_alerts = [parsed_alerts]

        if not isinstance(parsed_alerts, list):
            raise DemistoException('Parsed alerts template must be a dict or list of dicts.')

        return parsed_alerts


    def choose_ip(
        pattern: list[str] | str
    ) -> str:
        """ Choose an IP from IP list, IP range or CIDR.

        :param pattern: IP address pattern
        :return: Selected IP address.
        """
        if not isinstance(pattern, list):
            pattern = [pattern]

        pattern = random.choice(pattern)

        if m := re.fullmatch(r'([^-]+)-(.+)', pattern):
            ip = random.randint(int(ipaddress.IPv4Address(m[1])), int(ipaddress.IPv4Address(m[2])))
            return str(ipaddress.IPv4Address(ip))
        else:
            ip = ipaddress.IPv4Network(pattern, strict=False)
            return str(ip[random.randrange(0, ip.num_addresses)])


    def build_parsed_alert(
        template: dict[str, Any]
    ) -> dict[str, Any]:
        """ Build a parsed alert from a template

        :param template: Parsed alert template
        :return: A parsed alert generated.
        """
        if local_ip := template.get('local_ip'):
            local_ip = choose_ip(local_ip)

        if remote_ip := template.get('remote_ip'):
            remote_ip = choose_ip(remote_ip)

        if (local_port := template.get('local_port')) is None and 'local_port' in template:
            local_port = random.randint(1, 65534)
        elif isinstance(local_port, list):
            local_port = int(random.choice(local_port))

        if (remote_port := template.get('remote_port')) is None and 'remote_port' in template:
            remote_port = random.randint(1, 65534)
        elif isinstance(remote_port, list):
            remote_port = int(random.choice(remote_port))

        if event_timestamp := template.get('event_timestamp'):
            if isinstance(event_timestamp, str):
                event_timestamp = dateparser.parse(
                    event_timestamp,
                    settings={
                        'TIMEZONE': 'UTC',
                        'TO_TIMEZONE': 'UTC',
                        'RETURN_AS_TIMEZONE_AWARE': True
                    }
                ).timestamp() * 1000
        else:
            event_timestamp = int(datetime.now(timezone.utc).timestamp() * 1000)

        if severity := template.get('severity'):
            severity = severity.capitalize()
            if severity not in ('Critical', 'High', 'Medium', 'Low', 'Informational'):
                raise DemistoException(f'severity must be Critical, High, Medium, Low or Informational - {severity}')

        if action_status := template.get('action_status'):
            action_status = action_status.capitalize()
            if action_status not in ('Reported', 'Blocked'):
                raise DemistoException(f'action_status must be either Reported or Blocked - {action_status}')

        alert = assign_params(
            vendor=template.get('vendor', 'Unknown'),
            product=template.get('product', 'Unknown'),
            local_ip=local_ip,
            local_port=arg_to_number(local_port),
            remote_ip=remote_ip,
            remote_port=arg_to_number(remote_port),
            event_timestamp=event_timestamp,
            severity=severity,
            alert_name=template.get('alert_name'),
            alert_description=template.get('alert_description'),
            action_status=action_status,
            local_ip_v6=template.get('local_ip_v6'),
            remote_ip_v6=template.get('remote_ip_v6'),
        )
        return alert



    ''' CLASS DEFINITIONS '''


    class XsiamAPIKeyType(Enum):
        STANDARD = 'Standard'
        ADVANCED = 'Advanced'


    class XsiamClient(BaseClient):
        """ XSIAM Client class
        """
        API_NONCE_LENGTH = 64

        def __init__(
            self,
            params: dict[str, str]
        ) -> None:
            """ Initialize the instance

            :param params: Instance configuration parameters
            """
            base_url = params.get('xsiam_api_url')
            match (v := params.get('xsiam_apikey_type')):
                case XsiamAPIKeyType.STANDARD.value:
                    apikey_type = XsiamAPIKeyType.STANDARD
                case XsiamAPIKeyType.ADVANCED.value:
                    apikey_type = XsiamAPIKeyType.ADVANCED
                case _:
                    raise DemistoException(f'Invalid XSIAM API Key Type - {v}')

            creds = params.get('xsiam_credentials', {})
            apikey_id = creds.get('identifier')
            if not apikey_id:
                raise DemistoException('XSIAM API Key ID is required.')

            apikey_val = creds.get('password')
            if not apikey_val:
                raise DemistoException('XSIAM API Key is required.')

            insecure = params.get('insecure', False)
            proxy = params.get('proxy', False)

            super().__init__(base_url, not insecure, proxy)
            self.__apikey_type = apikey_type
            self.__apikey_id = apikey_id
            self.__apikey_value = apikey_val

        def __set_auth_headers(
            self,
            headers: dict[str, str]
        ) -> dict[str, str]:
            """ Build a new header with authentication parameters

            :param headers: The header fields
            :return: The new header fileds
            """
            headers = dict(**headers)
            match self.__apikey_type:
                case XsiamAPIKeyType.STANDARD:
                    headers['x-xdr-auth-id'] = self.__apikey_id
                    headers['Authorization'] = self.__apikey_value

                case XsiamAPIKeyType.ADVANCED:
                    nonce = ''.join(
                        [secrets.choice(string.ascii_letters + string.digits)
                        for _ in range(XsiamClient.API_NONCE_LENGTH)]
                    )
                    timestamp = str(
                        int(datetime.now(timezone.utc).timestamp() * 1000)
                    )
                    key_hash = hashlib.sha256(
                        (self.__apikey_value + nonce + timestamp).encode()
                    ).hexdigest()

                    headers['x-xdr-auth-id'] = self.__apikey_id
                    headers['x-xdr-timestamp'] = timestamp
                    headers['x-xdr-nonce'] = nonce
                    headers['Authorization'] = key_hash

                case _:
                    raise DemistoException(f'Invalid API key type - {self.__apikey_type.name}')

            return headers

        def request(
            self,
            method: str,
            path: str,
            body: dict[str, Any],
        ) -> dict[str, Any]:
            """ Request something to the API endpoint

            :param method: The HTTP request method
            :param path: The relative path of the API endpoint from the base URL
            :param body: The request data given to the API endpoint
            :return: The response data retrieved from the API endpoint.
            """
            resp = self._http_request(
                method=method,
                url_suffix=path,
                headers=self.__set_auth_headers({}),
                json_data=body
            )
            return resp

        def insert_parsed_alerts_by_template(
            self,
            alerts_template: list[dict[str, Any]],
            number_of_templates: int | None,
            number_of_clones: int,
            random_choices: bool,
            start_index: int = 0
        ) -> list[dict[str, Any]]:
            """ Build and insert parsed alerts

            :param alerts_template: Parsed alerts template
            :param number_of_templates: Number of templates to generate alerts
            :param number_of_clones: Number of alerts to clone for each alert template
            :param random_choices: True to choose alert templates randomly (ignore start_index), otherwise False.
            :param start_index: Index to read templates from alerts_template
            :return: List of alerts inserted.
            """
            if not alerts_template:
                raise DemistoException('Alerts template is required.')

            if not number_of_templates:
                number_of_templates = len(alerts_template)

            if random_choices:
                templates = random.choices(alerts_template, k=number_of_templates)
            else:
                start_index = min(0, start_index) % len(alerts_template)
                templates = alerts_template * ((number_of_templates // len(alerts_template)) + 1)
                templates = templates[start_index:start_index + number_of_templates]

            def _enum_alerts(
                templates: list[dict[str, Any]],
                number_of_clones: int,
            ) -> Iterator[list[dict[str, Any]]]:
                alerts = []
                for template in templates:
                    alert = build_parsed_alert(template)
                    event_timestamp = alert.get('event_timestamp') or 0
                    for i in range(0, max(1, number_of_clones)):
                        alerts.append(dict(alert, event_timestamp=event_timestamp + i))
                        if len(alerts) >= NUMBER_OF_ALERTS_IN_INSERT_PARSED_ALERTS_API:
                            yield alerts
                            alerts = []
                if alerts:
                    yield alerts

            alerts = []
            for request_alerts in _enum_alerts(templates, number_of_clones):
                self.request(
                    method='POST',
                    path='/public_api/v1/alerts/insert_parsed_alerts',
                    body={
                        'request_data': {
                            'alerts': request_alerts
                        }
                    }
                )
                alerts += request_alerts
            return alerts


    ''' COMMANDS '''

    def test_module(
        args: dict[str, str],
        params: dict[str, str],
    ) -> str:
        """
        Validates:
        """
        get_parsed_alerts_template(params)

        # Test to connect to XSIAM
        xc = XsiamClient(params)
        resp = xc.request(
            method='POST',
            path='/public_api/v1/incidents/get_incidents',
            body={
                'request_data': {
                    'search_from': 0,
                    'search_to': 1
                }
            }
        )
        if not resp.get('reply'):
            raise DemistoException(f'Invalid XSIAM API response - {json.dumps(resp)}')

        return 'ok'


    def fetch_incidents(
        args: dict[str, str],
        params: dict[str, str],
    ):
        if alerts_template := get_parsed_alerts_template(params):
            client = XsiamClient(params)
            number_of_clones = arg_to_number(params.get('number_of_clones')) or NUMBER_OF_CLONES_FOR_EACH_TEMPLATE
            number_of_templates = arg_to_number(params.get('number_of_templates'))
            if not number_of_templates:
                number_of_templates = len(alerts_template)

            if random_choices := params.get('random_choices', False):
                alerts = client.insert_parsed_alerts_by_template(
                    alerts_template=alerts_template,
                    number_of_templates=number_of_templates,
                    number_of_clones=number_of_clones,
                    random_choices=random_choices
                )
            else:
                last_index = int(demisto.getLastRun().get('last_index', -1))
                next_index = 0 if last_index < 0 else (last_index + 1) % len(alerts_template)

                alerts = client.insert_parsed_alerts_by_template(
                    alerts_template=alerts_template,
                    number_of_templates=number_of_templates,
                    number_of_clones=number_of_clones,
                    random_choices=random_choices,
                    start_index=next_index
                )
                demisto.setLastRun({
                    'last_index': (next_index + number_of_templates - 1) % len(alerts_template)
                })

        demisto.incidents([])


    def xsiam_alert_feed_run(
        args: dict[str, str],
        params: dict[str, str],
    ) -> str:
        alerts_template = get_parsed_alerts_template(params)
        if not alerts_template:
            raise DemistoException('Alerts template was not found.')

        alerts = XsiamClient(params).insert_parsed_alerts_by_template(
            alerts_template=alerts_template,
            number_of_templates=len(alerts_template),
            number_of_clones=arg_to_number(args.get('number_of_clones') or 1),
            random_choices=False,
            start_index=0
        )
        return f'{len(alerts)} alerts have been inserted.'


    def main():  # pragma: no cover
        try:
            args = demisto.args()
            params = demisto.params()
            command = demisto.command()
            LOG(f'Command being called is: {command}')

            commands = {
                'test-module': test_module,
                'fetch-incidents': fetch_incidents,
                'xsiam-alert-feed-run': xsiam_alert_feed_run
            }
            if function := commands.get(command):
                try:
                    return_results(function(assign_params(**args), params))
                except Exception as e:
                    raise
                    raise DemistoException(f'Failed to execute {command} command.\nError:\n{str(e)}')
            else:
                raise NotImplementedError(f'Command {command} is not implemented.')
        except Exception as err:
            raise
            return_error(str(err), error=traceback.format_exc())

        finally:
            LOG.print_log()


    if __name__ in ('__builtin__', 'builtins', '__main__'):
        main()

    register_module_line('XSIAM Alert Feed', 'end', __line__())
  type: python
  commands:
  - name: xsiam-alert-feed-run
    arguments:
    - name: number_of_clones
      description: Number of alerts to clone for each alert template
      defaultValue: "1"
    description: Feed alerts to XSIAM/XDR
  dockerimage: demisto/python3:3.10.13.89009
  isfetch: true
  runonce: false
  subtype: python3
sourcemoduleid: Panorama
