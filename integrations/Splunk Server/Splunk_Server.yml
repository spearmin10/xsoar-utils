commonfields:
  id: Splunk Server
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: Splunk Server
display: Splunk Server
category: Utilities
image: data:image/png;base64,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
description: Splunk Server on XSOAR
detaileddescription: "### How to configure the instance.\n\n#### 0.  Go to ABOUT >
  Troubleshooting > Server Configuration\nSet  instance.execute.external = true\n
  \ \nIf you failed to run the container due to the out of memory, please do this
  setting.\nSet `limit.docker.memory` = `false`\nSet `python.pass.extra.keys` = `--pids-limit=1024`\nAnd
  run `/reset_containers` in the CLI to take effect.\n\nSet `limit.docker.cpu` = `false`\nAnd
  run `/reset_containers` in the CLI to take effect if the CPU limit is applied for
  the docker.\n\n#### 1. Create a Splunk server instance\nAdd instance with the parameters
  below:\n  - Instance Name: splunk\n  - Listen Port: 8089\n  - Splunk Admin Password:
  Password123$\n\nYou can access the Splunk UI at\n  - https://xsoar-server/instance/execute/splunk/\n
  \  or\n  - http://xsoar-server:8089/\n    ```  \n      username: admin\n      password:
  Password123$\n    ```\n\nAlso, the REST API is available at\n   - http://xsoar-server:8089/\n
  \  or\n   - https://<your XSOAR GW IP>:8089/\n      e.g. https://172.17.0.1:8089/\n\n####
  2. Check the gateway address of the docker bridge network\nRun `!splunkd-get-gateways`
  in CLI, and memorize the gateway IP for the REST API\n\n### NOTE:\n - Data and configurations
  are gone whenever restarting the docker container."
configuration:
- display: Long Running Instance
  name: longRunning
  defaultvalue: "true"
  type: 8
  required: false
- display: Listen Port
  name: longRunningPort
  defaultvalue: "8089"
  type: 0
  required: true
  additionalinfo: Splunk Management Port
- display: Incident type
  name: incidentType
  type: 13
  required: false
- display: Splunk Admin Password
  name: adminPassword
  type: 4
  required: true
  additionalinfo: 'Default Password: Password123$'
- display: Syslog Port Mapping
  name: syslogPortMapping
  defaultvalue: "514"
  type: 12
  required: false
  additionalinfo: Send by UDP syslog from messages coming in the listening port
script:
  script: |
    import os
    import re
    import time
    import socket
    import select
    import subprocess
    import traceback
    import netifaces
    import ipaddress
    import urllib.parse
    from socketserver import BaseRequestHandler
    from socketserver import ThreadingTCPServer
    from socketserver import BaseServer
    from multiprocessing import Process
    from typing import List, Dict, Any, Pattern

    SPLUNK_MGMT_PORT = 189
    REVERSE_PROXY_SPLUNK_HTTP_PORT = 80

    DEFAULT_SOCKET_TIMEOUT = 30
    INTEGRATION_NAME = 'Splunk Server'

    SYSLOG_PORT_MAPPINGS: Dict[Optional[Pattern], int] = {}


    def update_context(params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Store the integration parameters to the integration context.

        :param params: The integration parameters
        :return: The integration context updated.
        """
        x = demisto.getIntegrationContext() or {}
        for k in ('longRunningPort'):
            if k in params:
                x[k] = params.get(k, '')

        x['instanceName'] = demisto.integrationInstance()

        demisto.setIntegrationContext(x)
        return x


    def is_restart_required(params: Dict[str, Any]) -> bool:
        """
        Check if the service restart is required

        :param params: The integration parameters
        :return: True - restart is required.
        """
        x = demisto.getIntegrationContext() or {}
        for k in ('longRunningPort'):
            if x.get(k, '') != params.get(k, ''):
                return True
        return x.get('instanceName') != demisto.integrationInstance()


    def start_services(params: Dict[str, Any]):
        """
        Start services

        :param params: The integration parameters
        """
        instance_name = demisto.integrationInstance()
        if instance_name != urllib.parse.quote(instance_name):
            demisto.debug(f'The instance name must not include any special/control charactors: {instance_name}')
        else:
            restart = is_restart_required(params)
            os.environ['SPLUNK_ROOT_ENDPOINT'] = '/instance/execute/' + instance_name
            os.environ['SPLUNK_ADMIN_PASSWORD'] = demisto.params()['adminPassword']
            ret = subprocess.call(['restart.sh' if restart else 'start.sh'])
            demisto.debug('A {}start command has been requested: {}'.format('re' if restart else '', ret))


    def get_gateway_interfaces() -> List[Dict[str, str]]:
        """
        Get the gateway interfaces

        :return: List of interfaces (keys: 'IP', 'Interface', 'Default')
        """
        return [{
            'IP': a[0] if len(a) > 0 else None,
            'Interface': a[1] if len(a) > 1 else None,
            'Default': a[2] if len(a) > 2 else None
        } for k, v in netifaces.gateways().items() if k != 'default' for a in v]


    def get_local_addresses() -> List[dict]:
        """
        Get local addresses

        :return: List of local address object {'addr', 'netmask', 'broadcast'}
        """
        alist = []
        for ifname in netifaces.interfaces():
            ifinfo = netifaces.ifaddresses(ifname)
            for ininfo in ifinfo.values():
                for ainfo in ininfo:
                    if ainfo.get('addr') and ainfo.get('netmask'):
                        try:
                            addr = ipaddress.ip_address(ainfo['addr'])
                            mask = ipaddress.ip_network(ainfo['netmask'], strict=False)
                            exploded = mask.broadcast_address.exploded
                            if addr.version == 4:
                                bcast = ipaddress.IPv4Address(int(addr) | (0xffffffff ^ int(ipaddress.IPv4Address(exploded))))
                                alist.append({
                                    'addr': addr,
                                    'netmask': mask,
                                    'broadcast': bcast
                                })
                        except ValueError:
                            pass
        return alist


    def make_port_mappings(params: Dict[str, Any]) -> Dict[Optional[Pattern], int]:
        """
        Make port mappings

        :param params: The integration parameters
        :return: Port mappings
        """
        port_map = json.loads(params.get('syslogPortMapping') or '514')
        if isinstance(port_map, (int, str)):
            return {None: int(port_map)}
        elif isinstance(port_map, dict):
            return {
                re.compile(pattern): int(port) for pattern, port in port_map.items()
            }
        raise ValueError('Invalid a syslog port mapping')


    class TcpPortForwardingHandler(BaseRequestHandler):
        """
        Port Forwarding for Splunk Management Port and Splunk Web UI
        """
        def forward_tcp(self, port: int):
            """
            TCP forwarding
            """
            cs = self.request
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as rs:
                    rs.connect(('127.0.0.1', port))
                    while True:
                        r, w, x = select.select([cs, rs], [], [])
                        if cs in r:
                            payload = cs.recv(1024)
                            if len(payload) == 0:
                                break
                            rs.send(payload)
                        if rs in r:
                            payload = rs.recv(1024)
                            if len(payload) == 0:
                                break
                            cs.send(payload)
            except Exception:
                demisto.debug(traceback.format_exc())
            finally:
                cs.close()

        def forward_syslog(self):
            """
            Syslog fowarding
            """
            with self.request.makefile('rb') as cs:
                for line_bin in cs:
                    line_str = line_bin.decode('utf-8', errors='ignore')
                    for pattern, port in SYSLOG_PORT_MAPPINGS.items():
                        if pattern is None or pattern.match(line_str):
                            # Send a syslog message
                            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as rs:
                                rs.sendto(line_bin, ('127.0.0.1', port))
                                break
                    else:
                        demisto.debug(f'No pattern match for {line_str}')

        def forward_syslog_with_size(self):
            """
            Syslog fowarding
            """
            cs = self.request
            while True:
                # Read payload size
                payload_size = 0
                while True:
                    c = cs.recv(1)
                    if len(c) == 0:
                        return
                    elif c == b' ':
                        break
                    payload_size = (payload_size * 10) + int(c)

                # Read payload
                if payload_size != 0:
                    payload_bin = cs.recv(payload_size)
                    payload_str = payload_bin.decode('utf-8', errors='ignore')
                    for pattern, port in SYSLOG_PORT_MAPPINGS.items():
                        if pattern is None or pattern.match(payload_str):
                            # Send a syslog message
                            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as rs:
                                rs.sendto(payload_bin, ('127.0.0.1', port))
                                break
                    else:
                        demisto.debug(f'No pattern match for {payload_str}')

        def handle_command(self):
            """
            Handle a command
            """
            with self.request.makefile('rb') as cs:
                try:
                    payload = cs.read().decode()
                    req = json.loads(payload)
                    demisto.debug(f'C: Request: {payload}')

                    cmd = req.get('command') or ''
                    if cmd == 'service-info':
                        resp = self.make_cmd_service_info()
                    else:
                        resp = {
                            'success': False,
                            'message': f'Unknown command: {cmd}'
                        }
                except Exception as e:
                    demisto.debug(traceback.format_exc())
                    resp = {
                        'success': False,
                        'message': str(e)
                    }
                finally:
                    payload = json.dumps(resp)
                    demisto.debug(f'C: Response: {payload}')
                    self.request.send(payload.encode())
                    self.request.close()

        def make_cmd_service_info(self) -> Dict[str, Any]:
            """
            Make a response to a service-info command

            :return: A response to service-info command
            """
            for ai in get_local_addresses():
                ip = str(ai['addr'])
                if ip not in ('127.0.0.1'):
                    return {
                        'success': True,
                        'service-info': {
                            'IP': ip,
                            'Name': demisto.integrationInstance()
                        }
                    }
            return {
                'success': False,
                'message': 'Unable to get service addresses'
            }

        def handle(self):
            c1 = self.request.recv(1, socket.MSG_PEEK)
            if c1 == b'\x16':
                self.forward_tcp(SPLUNK_MGMT_PORT)
            elif c1 == b'{':
                self.handle_command()
            elif c1 == b'<':
                self.forward_syslog()
            elif c1 in (b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9'):
                self.forward_syslog_with_size()
            else:
                self.forward_tcp(REVERSE_PROXY_SPLUNK_HTTP_PORT)


    def run_server(server: BaseServer, is_test=False):
        """
        Run the server

        :param server: The server instance
        :param is_test: Indicates whether it's test-module run or regular run
        :return: None
        """
        if is_test:
            svproc = Process(target=server.serve_forever)
            svproc.start()
            time.sleep(5)
            svproc.terminate()
        else:
            socket.setdefaulttimeout(DEFAULT_SOCKET_TIMEOUT)
            server.serve_forever()


    def run_long_running(params: Dict[str, Any], is_test=False):
        """
        Start the long running server

        :param params: Demisto params
        :param is_test: Indicates whether it's test-module run or regular run
        :return: None
        """
        try:
            longRunningPort = int(params['longRunningPort'])
            if longRunningPort < 0:
                raise ValueError(f'Invalid long running port: {longRunningPort}')
            if longRunningPort < 1024:
                raise ValueError(f'Listen ports less than 1024 are reserved for system: {longRunningPort}')

            if not is_test:
                start_services(params)
                update_context(params)

            # Run the server
            global SYSLOG_PORT_MAPPINGS
            SYSLOG_PORT_MAPPINGS = make_port_mappings(params)

            with ThreadingTCPServer(('', longRunningPort), TcpPortForwardingHandler) as server:
                run_server(server, is_test)

        except Exception as e:
            demisto.error(f'An error occurred in long running loop: {str(e)}')
            raise ValueError(str(e))


    ''' COMMANDS '''


    def test_module(args, params):
        """
        Validates:
        """
        raise RuntimeError('Please test with `splunkd-test` command.')


    def test_command(args, params):
        """
        Validates:
        """
        # Verify the instance name
        instance_name = demisto.integrationInstance()
        if instance_name != urllib.parse.quote(instance_name):
            raise ValueError(f"The instance name must not include any special/control charactors except for '_', '-', '.' and '~': {instance_name}")

        # Verify the port mappings
        make_port_mappings(params)

        # Check the server health
        _, _, tbl = get_gateways_command(None, None)
        if not tbl:
            raise RuntimeError('The gateway address was not found.')

        ip = tbl[0]['IP']
        port = int(params['longRunningPort'])

        BaseClient(base_url=f'http://{ip}:{port}')._http_request(
            'GET',
            url_suffix='/',
            retries=7,
            backoff_factor=1,
            resp_type='response',
            status_list_to_retry=[500, 502, 504])

        return 'ok', {}, {}


    def get_service_info_command(args, params):
        """
        Get service information
        """
        port = int(params['longRunningPort'])

        # Get the gateway IP
        ifs = get_gateway_interfaces()
        if not ifs:
            return 'No gateway addresses', {}, []

        gw_ip = ifs[0]['IP']

        # Get the service information
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((gw_ip, port))

            # Send a request
            s.send(json.dumps({
                'command': 'service-info'
            }).encode())
            s.shutdown(socket.SHUT_WR)

            # Receive a response
            with s.makefile('rb') as r:
                resp = json.load(r)

            if not resp['success']:
                return resp.get('message') or '', {}, []

            sinfo = resp['service-info']

        # Format the service information
        ec = {
            'Splunkd': {
                'Service': {
                    'IP': sinfo['IP'],
                    'Name': sinfo['Name']
                }
            }
        }
        hr = tblToMd('Service', demisto.get(ec, 'Splunkd.Service'))
        return hr, ec, sinfo


    def get_gateways_command(args, params):
        """
        Get list of gateways
        """
        ifs = get_gateway_interfaces()
        if ifs:
            hr = tblToMd('Gateways', ifs)
            return hr, {'Splunkd.Gateway': ifs}, ifs
        else:
            hr = 'No gateway addresses'
            return hr, {}, []


    def main():
        """
        Main
        """
        params = demisto.params()

        command = demisto.command()
        demisto.debug('Command being called is {}'.format(command))
        commands = {
            'test-module': test_module,
            'splunkd-test': test_command,
            'splunkd-get-service-info': get_service_info_command,
            'splunkd-get-gateways': get_gateways_command
        }
        try:
            if command == 'long-running-execution':
                run_long_running(params)
            else:
                readable_output, outputs, raw_response = commands[command](demisto.args(), params)
                return_outputs(readable_output, outputs, raw_response)
        except Exception as e:
            err_msg = f'Error in {INTEGRATION_NAME} Integration [{e}]'
            return_error(err_msg)


    if __name__ in ['__main__', '__builtin__', 'builtins']:
        main()
  type: python
  commands:
  - name: splunkd-get-gateways
    arguments: []
    outputs:
    - contextPath: Splunkd.Gateway.IP
      description: The IP address of the gateway
      type: string
    - contextPath: Splunkd.Gateway.Interface
      description: The interface name
      type: string
    - contextPath: Splunkd.Gateway.Default
      description: True if the IP is Default gateway
      type: boolean
    description: Get gateway addresses of the instance running
  - name: splunkd-test
    arguments: []
    description: Test the instance
  - name: splunkd-get-service-info
    arguments: []
    outputs:
    - contextPath: Splunkd.Service.IP
      description: The IP address on which the service is running
    - contextPath: Splunkd.Service.Name
      description: The instance name of the service
    description: Get the service information
  dockerimage: spearmint/xsoar-splunk:1.12.14.2354
  runonce: true
  longRunning: true
  longRunningPort: true
  subtype: python3
sourcemoduleid: ExportIndicators
